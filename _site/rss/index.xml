<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>THIS IS YOUR LIFE</title>
    <description>세상에는 배울 것이 너무나도 많고 저는 항상 부족합니다.
언젠가 제가 배우고 익힌 지식이 누군가에게 도움이 되길 원합니다.
</description>
    <link>http://localhost:8080/</link>
    <atom:link href="http://localhost:8080/rss" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 22 Jan 2018 01:19:50 +0900</pubDate>
    <lastBuildDate>Mon, 22 Jan 2018 01:19:50 +0900</lastBuildDate>
    <generator>Jekyll v3.5.1</generator>
    
      <item>
        <title>Q&amp;A a day, 2. Can people change?</title>
        <description>&lt;h1 id=&quot;두-번째-질문-can-people-change&quot;&gt;두 번째 질문, Can people change?&lt;/h1&gt;
&lt;!--more--&gt;
&lt;p&gt;변할 수 있다. 당장 나만해도 저번 주 수요일부터 바뀌었다.&lt;br /&gt;
이 변화가 언제까지 갈지는 미지수지만, 사람은 동기가 있다면 언제든 바뀐다!&lt;/p&gt;
</description>
        <pubDate>Wed, 17 Jan 2018 09:00:00 +0900</pubDate>
        <link>http://localhost:8080/daily/can-people-change/</link>
        <guid isPermaLink="true">http://localhost:8080/daily/can-people-change/</guid>
        
        <category>daily</category>
        
        <category>questions</category>
        
        
        <category>daily</category>
        
      </item>
    
      <item>
        <title>Q&amp;A a day, 1. What is your purpose in life?</title>
        <description>&lt;h1 id=&quot;5년-후-나에게---qa-a-day&quot;&gt;5년 후 나에게 - Q&amp;amp;A a Day&lt;/h1&gt;
&lt;!--more--&gt;
&lt;p&gt;LG Dream Challenger는 제게 ‘꿈’,’열정’ 등 동기부여가 정말 많이 일어났습니다.
그래서 책을 왕창 사버렸는데, 그 중 하나인 5년 후 나에게 - Q&amp;amp;A a Day에 대해 포스팅을 해볼까 합니다.
&lt;br /&gt;이 책에는 365개의 질문이 수록돼있고, 5년간 적을 수 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;첫-번째-질문-what-is-your-purpose-in-life&quot;&gt;첫 번째 질문, What is your purpose in life?&lt;/h1&gt;
&lt;p&gt;좋은 아버지가 되고 싶다. 그러려면 돈이 필요할 테지만, 미래의 나는 돈이 많겠지…?&lt;br /&gt;
또 인정받는 사회적 지도자가 되고 싶다.&lt;br /&gt;
내가 어렸을 때 힘들었던 경험을 떠올리면 청소년들이 그런 아픔을 겪게 하고 싶지 않다. &lt;br /&gt;
나는 자라나는 꿈들에게 세상의 따뜻함을 전하고 싶다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;the-holstee-manifesto-lifecycle-video&quot;&gt;The Holstee Manifesto: Lifecycle Video&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://youtu.be/QDmt_t6umoY&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.youtube.com/vi/QDmt_t6umoY/0.jpg&quot; alt=&quot;Holstee Manifesto&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이 영상은 대외활동을 하면서 알게 된 동영상인데, 정말 많은 영감을 주고 동기부여가 많이 된다.
&lt;br /&gt;
첫 포스팅의 시작으로 안성맞춤일 것 같아서 삽입 :)&lt;/p&gt;
</description>
        <pubDate>Tue, 16 Jan 2018 09:00:00 +0900</pubDate>
        <link>http://localhost:8080/daily/what-is-your-purpose-in-life/</link>
        <guid isPermaLink="true">http://localhost:8080/daily/what-is-your-purpose-in-life/</guid>
        
        <category>daily</category>
        
        <category>questions</category>
        
        
        <category>daily</category>
        
      </item>
    
      <item>
        <title>블로그를 시작합니다</title>
        <description>&lt;h1 id=&quot;블로그를-시작한-이유&quot;&gt;블로그를 시작한 이유&lt;/h1&gt;
&lt;!--more--&gt;

&lt;p&gt;세상에 제 생각을 정리하는 공간을 만들고 싶어졌습니다.&lt;/p&gt;

&lt;h2 id=&quot;굳이-github-pages-인-이유&quot;&gt;굳이 GitHub Pages 인 이유&lt;/h2&gt;

&lt;p&gt;저는 전자공학과 학생이고, 컴퓨터, 특히 인공지능에 관심이 많습니다.
깃헙과 친해지고 싶기도하고, 저만의 페이지를 만들고 싶었습니다.
또 깃헙은 안망할것 같기도 해서… ㅎ&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;감사&quot;&gt;감사&lt;/h2&gt;

&lt;p&gt;블로그를 시작할 동기를 부여해준 LG Dream Challenger 정말 감사합니다.&lt;/p&gt;
</description>
        <pubDate>Mon, 15 Jan 2018 13:11:00 +0900</pubDate>
        <link>http://localhost:8080/daily/blog-start/</link>
        <guid isPermaLink="true">http://localhost:8080/daily/blog-start/</guid>
        
        <category>daily</category>
        
        
        <category>daily</category>
        
      </item>
    
      <item>
        <title>카카오 신입 공채 3차 코딩 테스트 문제 해설</title>
        <description>&lt;p&gt;블라인드 채용으로 관심을 모은 카카오 신입 공채의 세 번째 테스트가 지난 10월 29일(일), 오후 2시부터 6시까지 네 시간에 걸쳐 오프라인으로 치러졌습니다. 두 차례의 온라인 테스트를 통과한 지원자들이 한 자리에 모여 다시 한번 실력을 검증하는 자리를 가졌습니다.&lt;/p&gt;

&lt;h1 id=&quot;세-번째-관문&quot;&gt;세 번째 관문&lt;/h1&gt;
&lt;p&gt;오프라인 코딩 테스트는 온라인 코딩 테스트와는 사뭇 달랐습니다. 1차와 2차 코딩 테스트에서 상위권의 우수한 성적을 거뒀던 지원자가 3차 코딩 테스트의 관문을 통과하지 못한 경우도 있었습니다. 현장에 와서 다른 지원자와 함께 경쟁한다는 긴장감도 있을 테고요. 자신이 쓰던 집이나 학교의 컴퓨터가 아니어 불편했을 겁니다. OS나 IDE 등의 개발 환경도 평소 자신이 쓰던 것과 달랐을 겁니다. 특히나 문제를 풀다가 막혔을 때 애용하던 “검색 찬스”도 쓸 수 없을 테고요.&lt;/p&gt;

&lt;p&gt;1차 코딩 테스트에서 Java 언어 사용자들이 고전했다면, 2차와 3차 코딩 테스트에서는 C++ 사용자들이 힘들어했습니다.
1차 응시자들은 대부분 3차 코딩 테스트에서도 같은 언어로 시험을 봤습니다. 다만, 1차에서 여러 언어를 사용하던 지원자들은 3차에서는 절반 가량이 Python을 주 언어로 코딩 테스트에 참가했습니다.&lt;/p&gt;

&lt;p&gt;이번 3차 테스트에서는 코딩 테스트와 함께 지원자들의 컴퓨팅 관련 기본 지식을 묻는 필기 시험도 함께 치러졌습니다. 사전에 알리지 않고 현장에 와서 필기 시험이 치러진다는 안내를 받고 조금은 놀라셨을 텐데요. 평소 실력이 있는 지원자들인지라 대부분 잘 답하셨더군요.&lt;/p&gt;

&lt;p&gt;합격 기준은 코딩 문제 5 문제 중 3 문제 이상, 필기 시험 40점 이상을 기준으로 삼았습니다. 필기 시험은 준비없이 치렀다는 점을 고려하여 기준을 낮게 잡았습니다.&lt;/p&gt;

&lt;h1 id=&quot;코딩-문제-설명&quot;&gt;코딩 문제 설명&lt;/h1&gt;
&lt;p&gt;이번 3차 테스트에서는 코딩 테스트로 다섯 문제를 준비했습니다. 1차 테스트처럼 기초적인 구현 능력을 검증하는 문제들입니다. 1차 테스트와 난이도 면에서 크게 차이는 없지만, 조금은 더 복합적으로 생각하고 구현해야 하는 문제들이 많았습니다.&lt;/p&gt;

&lt;h2 id=&quot;문제1-n진수-게임&quot;&gt;문제1. N진수 게임&lt;/h2&gt;
&lt;p&gt;튜브가 활동하는 코딩 동아리에서는 전통적으로 해오는 게임이 있다. 이 게임은 여러 사람이 둥글게 앉아서 숫자를 하나씩 차례대로 말하는 게임인데, 규칙은 다음과 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;숫자를 0부터 시작해서 차례대로 말한다. 첫 번째 사람은 0, 두 번째 사람은 1, … 열 번째 사람은 9를 말한다.&lt;/li&gt;
  &lt;li&gt;10 이상의 숫자부터는 한 자리씩 끊어서 말한다. 즉 열한 번째 사람은 10의 첫 자리인 1, 열두 번째 사람은 둘째 자리인 0을 말한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이렇게 게임을 진행할 경우,&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 0, 1, 1, 1, 2, 1, 3, 1, 4, …&lt;/code&gt;&lt;br /&gt;
순으로 숫자를 말하면 된다.&lt;/p&gt;

&lt;p&gt;한편 코딩 동아리 일원들은 컴퓨터를 다루는 사람답게 이진수로 이 게임을 진행하기도 하는데, 이 경우에는&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, …&lt;/code&gt;&lt;br /&gt;
순으로 숫자를 말하면 된다.&lt;/p&gt;

&lt;p&gt;이진수로 진행하는 게임에 익숙해져 질려가던 사람들은 좀 더 난이도를 높이기 위해 이진법에서 십육진법까지 모든 진법으로 게임을 진행해보기로 했다. 숫자 게임이 익숙하지 않은 튜브는 게임에 져서 벌칙을 받는 굴욕을 피하기 위해, 자신이 말해야 하는 숫자를 스마트폰에 미리 출력해주는 프로그램을 만들려고 한다. 튜브의 프로그램을 구현하라.&lt;/p&gt;

&lt;h3 id=&quot;입력-형식&quot;&gt;입력 형식&lt;/h3&gt;
&lt;p&gt;진법 &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;,  미리 구할 숫자의 갯수 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;, 게임에 참가하는 인원 &lt;code class=&quot;highlighter-rouge&quot;&gt;m&lt;/code&gt;, 튜브의 순서 &lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt; 가 주어진다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;2 ≦ &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; ≦ 16&lt;/li&gt;
  &lt;li&gt;0 ＜ &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; ≦ 1000&lt;/li&gt;
  &lt;li&gt;2 ≦ &lt;code class=&quot;highlighter-rouge&quot;&gt;m&lt;/code&gt; ≦ 100&lt;/li&gt;
  &lt;li&gt;1 ≦ &lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt; ≦ &lt;code class=&quot;highlighter-rouge&quot;&gt;m&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;출력-형식&quot;&gt;출력 형식&lt;/h3&gt;
&lt;p&gt;튜브가 말해야 하는 숫자 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;개를 공백 없이 차례대로 나타낸 문자열. 단, &lt;code class=&quot;highlighter-rouge&quot;&gt;10&lt;/code&gt;~&lt;code class=&quot;highlighter-rouge&quot;&gt;15&lt;/code&gt;는 각각 대문자 &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;~&lt;code class=&quot;highlighter-rouge&quot;&gt;F&lt;/code&gt;로 출력한다.&lt;/p&gt;

&lt;h3 id=&quot;입출력-예제&quot;&gt;입출력 예제&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;n&lt;/th&gt;
      &lt;th&gt;t&lt;/th&gt;
      &lt;th&gt;m&lt;/th&gt;
      &lt;th&gt;p&lt;/th&gt;
      &lt;th&gt;result&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;“0111”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;16&lt;/td&gt;
      &lt;td&gt;16&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;“02468ACE11111111”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;16&lt;/td&gt;
      &lt;td&gt;16&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;“13579BDF01234567”&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;문제-해설&quot;&gt;문제 해설&lt;/h3&gt;
  &lt;p&gt;반복문과 진법 변환을 할 수 있다면 어렵지 않게 풀 수 있는 문제입니다. 진법 변환은 프로그래밍 언어를 처음 배울 때 연습 문제로 많이 풀어봤을 문제일 텐데요. 오래간만에 풀어보려니 쉽지만은 않았던 듯 싶습니다.&lt;/p&gt;

  &lt;p&gt;참고로 이 문제는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Champernowne_constant&quot;&gt;챔퍼나운 수&lt;/a&gt;라는 수학 상수를 이용한 문제입니다.&lt;/p&gt;

  &lt;p&gt;이 문제의 정답률은 91.85%였습니다. 대부분 잘 풀어주셨으나, 언어별로는 C++ 사용자들이 약간 어려워했습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;문제2-압축&quot;&gt;문제2. 압축&lt;/h2&gt;
&lt;p&gt;신입사원 어피치는 카카오톡으로 전송되는 메시지를 압축하여 전송 효율을 높이는 업무를 맡게 되었다. 메시지를 압축하더라도 전달되는 정보가 바뀌어서는 안 되므로, 압축 전의 정보를 완벽하게 복원 가능한 무손실 압축 알고리즘을 구현하기로 했다.&lt;/p&gt;

&lt;p&gt;어피치는 여러 압축 알고리즘 중에서 성능이 좋고 구현이 간단한 &lt;strong&gt;LZW&lt;/strong&gt;(Lempel–Ziv–Welch) 압축을 구현하기로 했다. LZW 압축은 1983년 발표된 알고리즘으로, 이미지 파일 포맷인 GIF 등 다양한 응용에서 사용되었다.&lt;/p&gt;

&lt;p&gt;LZW 압축은 다음 과정을 거친다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;길이가 1인 모든 단어를 포함하도록 사전을 초기화한다.&lt;/li&gt;
  &lt;li&gt;사전에서 현재 입력과 일치하는 가장 긴 문자열 &lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt;를 찾는다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt;에 해당하는 사전의 색인 번호를 출력하고, 입력에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt;를 제거한다.&lt;/li&gt;
  &lt;li&gt;입력에서 처리되지 않은 다음 글자가 남아있다면(&lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;), &lt;code class=&quot;highlighter-rouge&quot;&gt;w+c&lt;/code&gt;에 해당하는 단어를 사전에 등록한다.&lt;/li&gt;
  &lt;li&gt;단계 2로 돌아간다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;압축 알고리즘이 영문 대문자만 처리한다고 할 때, 사전은 다음과 같이 초기화된다. 사전의 색인 번호는 정수값으로 주어지며, 1부터 시작한다고 하자.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;색인 번호&lt;/th&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;th&gt;…&lt;/th&gt;
      &lt;th&gt;24&lt;/th&gt;
      &lt;th&gt;25&lt;/th&gt;
      &lt;th&gt;26&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;단어&lt;/td&gt;
      &lt;td&gt;A&lt;/td&gt;
      &lt;td&gt;B&lt;/td&gt;
      &lt;td&gt;C&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td&gt;X&lt;/td&gt;
      &lt;td&gt;Y&lt;/td&gt;
      &lt;td&gt;Z&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;예를 들어 입력으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;KAKAO&lt;/code&gt;가 들어온다고 하자.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;현재 사전에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;KAKAO&lt;/code&gt;의 첫 글자 &lt;code class=&quot;highlighter-rouge&quot;&gt;K&lt;/code&gt;는 등록되어 있으나, 두 번째 글자까지인 &lt;code class=&quot;highlighter-rouge&quot;&gt;KA&lt;/code&gt;는 없으므로, 첫 글자 &lt;code class=&quot;highlighter-rouge&quot;&gt;K&lt;/code&gt;에 해당하는 색인 번호 11을 출력하고, 다음 글자인 &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;를 포함한 &lt;code class=&quot;highlighter-rouge&quot;&gt;KA&lt;/code&gt;를 사전에 27 번째로 등록한다.&lt;/li&gt;
  &lt;li&gt;두 번째 글자 &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;는 사전에 있으나, 세 번째 글자까지인 &lt;code class=&quot;highlighter-rouge&quot;&gt;AK&lt;/code&gt;는 사전에 없으므로, &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;의  색인 번호 1을 출력하고, &lt;code class=&quot;highlighter-rouge&quot;&gt;AK&lt;/code&gt;를 사전에 28 번째로 등록한다.&lt;/li&gt;
  &lt;li&gt;세 번째 글자에서 시작하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;KA&lt;/code&gt;가 사전에 있으므로, &lt;code class=&quot;highlighter-rouge&quot;&gt;KA&lt;/code&gt;에 해당하는 색인 번호 27을 출력하고, 다음 글자 &lt;code class=&quot;highlighter-rouge&quot;&gt;O&lt;/code&gt;를 포함한 &lt;code class=&quot;highlighter-rouge&quot;&gt;KAO&lt;/code&gt;를 29 번째로 등록한다.&lt;/li&gt;
  &lt;li&gt;마지막으로 처리되지 않은 글자 &lt;code class=&quot;highlighter-rouge&quot;&gt;O&lt;/code&gt;에 해당하는 색인 번호 15를 출력한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;현재 입력(w)&lt;/th&gt;
      &lt;th&gt;다음 글자(c)&lt;/th&gt;
      &lt;th&gt;출력&lt;/th&gt;
      &lt;th&gt;사전 추가(w+c)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;K&lt;/td&gt;
      &lt;td&gt;A&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;27: KA&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;A&lt;/td&gt;
      &lt;td&gt;K&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;28: AK&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;KA&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;27&lt;/td&gt;
      &lt;td&gt;29: KAO&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;15&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;이 과정을 거쳐 다섯 글자의 문장 &lt;code class=&quot;highlighter-rouge&quot;&gt;KAKAO&lt;/code&gt;가 4개의 색인 번호 [11, 1, 27, 15]로 압축된다.&lt;/p&gt;

&lt;p&gt;입력으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;TOBEORNOTTOBEORTOBEORNOT&lt;/code&gt;가 들어오면 다음과 같이 압축이 진행된다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;현재 입력(w)&lt;/th&gt;
      &lt;th&gt;다음 글자(c)&lt;/th&gt;
      &lt;th&gt;출력&lt;/th&gt;
      &lt;th&gt;사전 추가(w+c)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;27: TO&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;B&lt;/td&gt;
      &lt;td&gt;15&lt;/td&gt;
      &lt;td&gt;28: OB&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;B&lt;/td&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;29: BE&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;30: EO&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;R&lt;/td&gt;
      &lt;td&gt;15&lt;/td&gt;
      &lt;td&gt;31: OR&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;R&lt;/td&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;18&lt;/td&gt;
      &lt;td&gt;32: RN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;N&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;14&lt;/td&gt;
      &lt;td&gt;33: NO&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;15&lt;/td&gt;
      &lt;td&gt;34: OT&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
      &lt;td&gt;35: TT&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TO&lt;/td&gt;
      &lt;td&gt;B&lt;/td&gt;
      &lt;td&gt;27&lt;/td&gt;
      &lt;td&gt;36: TOB&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;BE&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;29&lt;/td&gt;
      &lt;td&gt;37: BEO&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;OR&lt;/td&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;31&lt;/td&gt;
      &lt;td&gt;38: ORT&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;TOB&lt;/td&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;36&lt;/td&gt;
      &lt;td&gt;39: TOBE&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;EO&lt;/td&gt;
      &lt;td&gt;R&lt;/td&gt;
      &lt;td&gt;30&lt;/td&gt;
      &lt;td&gt;40: EOR&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RN&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;32&lt;/td&gt;
      &lt;td&gt;41: RNO&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;OT&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;34&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;입력-형식-1&quot;&gt;입력 형식&lt;/h3&gt;
&lt;p&gt;입력으로 영문 대문자로만 이뤄진 문자열 &lt;code class=&quot;highlighter-rouge&quot;&gt;msg&lt;/code&gt;가 주어진다. &lt;code class=&quot;highlighter-rouge&quot;&gt;msg&lt;/code&gt;의 길이는 1 글자 이상, 1000 글자 이하이다.&lt;/p&gt;

&lt;h3 id=&quot;출력-형식-1&quot;&gt;출력 형식&lt;/h3&gt;
&lt;p&gt;주어진 문자열을 압축한 후의 사전 색인 번호를 배열로 출력하라.&lt;/p&gt;

&lt;h3 id=&quot;입출력-예제-1&quot;&gt;입출력 예제&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;msg&lt;/th&gt;
      &lt;th&gt;answer&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;KAKAO&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;[11, 1, 27, 15]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TOBEORNOTTOBEORTOBEORNOT&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;[20, 15, 2, 5, 15, 18, 14, 15, 20, 27, 29, 31, 36, 30, 32, 34]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ABABABABABABABAB&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;[1, 2, 27, 29, 28, 31, 30]&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;문제-해설-1&quot;&gt;문제 해설&lt;/h3&gt;
  &lt;p&gt;GIF 파일 등에서 실제로 쓰이는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Lempel–Ziv–Welch&quot;&gt;LZW 알고리즘&lt;/a&gt;을 설명해주고, 구현하는 문제입니다. 실제로 쓰이는 알고리즘을 구현해보는 것이 어떠셨나요? 압축이라는 말만으로 얼핏 어려워 보이지만, 설명에 나온 의사코드&lt;sup&gt;Pseudocode&lt;/sup&gt;를 그대로 따라서 구현만 하면 되는 문제로, 기초적인 문자열과 배열을 다룰 수 있다면 풀 수 있는 문제입니다.&lt;/p&gt;

  &lt;p&gt;이 문제의 정답률은 95.80%입니다. 가장 많은 지원자가 잘 풀어주셨습니다. 언어별로는 Java 언어 사용자들이 조금 어려워했습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;문제3-파일명-정렬&quot;&gt;문제3. 파일명 정렬&lt;/h2&gt;
&lt;p&gt;세 차례의 코딩 테스트와 두 차례의 면접이라는 기나긴 블라인드 공채를 무사히 통과해 카카오에 입사한 무지는 파일 저장소 서버 관리를 맡게 되었다.&lt;/p&gt;

&lt;p&gt;저장소 서버에는 프로그램의 과거 버전을 모두 담고 있어, 이름 순으로 정렬된 파일 목록은 보기가 불편했다. 파일을 이름 순으로 정렬하면 나중에 만들어진 ver-10.zip이 ver-9.zip보다 먼저 표시되기 때문이다.&lt;/p&gt;

&lt;p&gt;버전 번호 외에도 숫자가 포함된 파일 목록은 여러 면에서 관리하기 불편했다. 예컨대 파일 목록이 [“img12.png”, “img10.png”, “img2.png”, “img1.png”]일 경우, 일반적인 정렬은 [“img1.png”, “img10.png”, “img12.png”, “img2.png”] 순이 되지만, 숫자 순으로 정렬된 [“img1.png”, “img2.png”, “img10.png”, img12.png”] 순이 훨씬 자연스럽다.&lt;/p&gt;

&lt;p&gt;무지는 단순한 문자 코드 순이 아닌, 파일명에 포함된 숫자를 반영한 정렬 기능을 저장소 관리 프로그램에 구현하기로 했다.&lt;/p&gt;

&lt;p&gt;소스 파일 저장소에 저장된 파일명은 100 글자 이내로, 영문 대소문자, 숫자, 공백(“ “), 마침표(“.”), 빼기 부호(“-“)만으로 이루어져 있다. 파일명은 영문자로 시작하며, 숫자를 하나 이상 포함하고 있다.&lt;/p&gt;

&lt;p&gt;파일명은 크게 HEAD, NUMBER, TAIL의 세 부분으로 구성된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HEAD는 숫자가 아닌 문자로 이루어져 있으며, 최소한 한 글자 이상이다.&lt;/li&gt;
  &lt;li&gt;NUMBER는 한 글자에서 최대 다섯 글자 사이의 연속된 숫자로 이루어져 있으며, 앞쪽에 0이 올 수 있다. &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;부터 &lt;code class=&quot;highlighter-rouge&quot;&gt;99999&lt;/code&gt; 사이의 숫자로, &lt;code class=&quot;highlighter-rouge&quot;&gt;00000&lt;/code&gt;이나 &lt;code class=&quot;highlighter-rouge&quot;&gt;0101&lt;/code&gt; 등도 가능하다.&lt;/li&gt;
  &lt;li&gt;TAIL은 그 나머지 부분으로, 여기에는 숫자가 다시 나타날 수도 있으며, 아무 글자도 없을 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;파일명&lt;/th&gt;
      &lt;th&gt;HEAD&lt;/th&gt;
      &lt;th&gt;NUMBER&lt;/th&gt;
      &lt;th&gt;TAIL&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;foo9.txt&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;9&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.txt&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;foo010bar020.zip&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;foo&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;010&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bar020.zip&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;F-15&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;F-&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;15&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;(빈 문자열)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;파일명을 세 부분으로 나눈 후, 다음 기준에 따라 파일명을 정렬한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;파일명은 우선 HEAD 부분을 기준으로 사전 순으로 정렬한다. 이때, 문자열 비교 시 대소문자 구분을 하지 않는다. &lt;code class=&quot;highlighter-rouge&quot;&gt;MUZI&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;muzi&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;MuZi&lt;/code&gt;는 정렬 시에 같은 순서로 취급된다.&lt;/li&gt;
  &lt;li&gt;파일명의 HEAD 부분이 대소문자 차이 외에는 같을 경우, NUMBER의 숫자 순으로 정렬한다. 9 &amp;lt; 10 &amp;lt; 0011 &amp;lt; 012 &amp;lt; 13 &amp;lt; 014 순으로 정렬된다. 숫자 앞의 0은 무시되며, 012와 12는 정렬 시에 같은 같은 값으로 처리된다.&lt;/li&gt;
  &lt;li&gt;두 파일의 HEAD 부분과, NUMBER의 숫자도 같을 경우, 원래 입력에 주어진 순서를 유지한다. &lt;code class=&quot;highlighter-rouge&quot;&gt;MUZI01.zip&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;muzi1.png&lt;/code&gt;가 입력으로 들어오면, 정렬 후에도 입력 시 주어진 두 파일의 순서가 바뀌어서는 안 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;무지를 도와 파일명 정렬 프로그램을 구현하라.&lt;/p&gt;

&lt;h3 id=&quot;입력-형식-2&quot;&gt;입력 형식&lt;/h3&gt;
&lt;p&gt;입력으로 배열 &lt;code class=&quot;highlighter-rouge&quot;&gt;files&lt;/code&gt;가 주어진다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;files&lt;/code&gt;는 1000 개 이하의 파일명을 포함하는 문자열 배열이다.&lt;/li&gt;
  &lt;li&gt;각 파일명은 100 글자 이하 길이로, 영문 대소문자, 숫자, 공백(“ “), 마침표(“.”), 빼기 부호(“-“)만으로 이루어져 있다. 파일명은 영문자로 시작하며, 숫자를 하나 이상 포함하고 있다.&lt;/li&gt;
  &lt;li&gt;중복된 파일명은 없으나, 대소문자나 숫자 앞부분의 0 차이가 있는 경우는 함께 주어질 수 있다. (&lt;code class=&quot;highlighter-rouge&quot;&gt;muzi1.txt&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;MUZI1.txt&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;muzi001.txt&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;muzi1.TXT&lt;/code&gt;는 함께 입력으로 주어질 수 있다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;출력-형식-2&quot;&gt;출력 형식&lt;/h3&gt;
&lt;p&gt;위 기준에 따라 정렬된 배열을 출력한다.&lt;/p&gt;

&lt;h3 id=&quot;입출력-예제-2&quot;&gt;입출력 예제&lt;/h3&gt;

&lt;p&gt;입력: [“img12.png”, “img10.png”, “img02.png”, “img1.png”, “IMG01.GIF”, “img2.JPG”]&lt;br /&gt;
출력: [“img1.png”, “IMG01.GIF”, “img02.png”, “img2.JPG”, “img10.png”, “img12.png”]&lt;/p&gt;

&lt;p&gt;입력: [“F-5 Freedom Fighter”, “B-50 Superfortress”, “A-10 Thunderbolt II”, “F-14 Tomcat”]&lt;br /&gt;
출력: [“A-10 Thunderbolt II”, “B-50 Superfortress”, “F-5 Freedom Fighter”, “F-14 Tomcat”]&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;문제-해설-2&quot;&gt;문제 해설&lt;/h3&gt;
  &lt;p&gt;코딩의 기초 문제라고 할 수 있는 정렬 문제입니다. 하지만 조건은 꽤나 복합적입니다. 파일명을 세 부분으로 나눠, 첫 부분은 대소문자 구분 없이&lt;sup&gt;Case Insensitive&lt;/sup&gt;, 다음 부분은 숫자 값에 따라&lt;sup&gt;Numerical&lt;/sup&gt; 정렬해야 합니다. 또한 정렬 기준에 따라 차이가 없다면 원래 입력에서 주어진 순서를 유지하는 안정 정렬&lt;sup&gt;Stable Sort&lt;/sup&gt;을 사용해야 합니다. 정렬 문제를 풀 때 한 번씩은 다 해보셨죠? 그런데 이걸 어떻게 꿰어서 하나의 프로그램으로 만들어야 할지 어려워하시더군요.&lt;/p&gt;

  &lt;p&gt;여러 정렬 알고리즘을 배우셨을 텐데요. 이 중에 안정 정렬이 어떤 건지 알고 계신가요? 빠른 정렬 알고리즘으로 가장 유명한 퀵 정렬&lt;sup&gt;Quick Sort&lt;/sup&gt;는 아쉽게도 안정 정렬이 아닙니다. 효율이 좋은 O(n log n) 복잡도의 정렬 알고리즘 중에는 병합 정렬&lt;sup&gt;Merge Sort&lt;/sup&gt; 등 일부 알고리즘은 안정 정렬이고요. 효율이 떨어지는 O(n&lt;sup&gt;2&lt;/sup&gt;) 복잡도의 알고리즘 중 버블 정렬&lt;sup&gt;Bubble Sort&lt;/sup&gt;과 삽입 정렬&lt;sup&gt;Insertion Sort&lt;/sup&gt;은 모두 안정 정렬입니다. 여러분이 아는 다른 알고리즘도 안정 정렬인지 아닌지 확인해보세요. 알고리즘의 구현 방법에 따라 같은 알고리즘이라도 안정 정렬이거나 아닐 수도 있습니다.&lt;/p&gt;

  &lt;p&gt;정렬 문제가 워낙 많이 쓰이므로 많은 프로그래밍 언어에서 정렬 알고리즘을 기본 함수로 제공하고 있습니다. 자신이 사용하는 프로그래밍 언어에서 안정 정렬 알고리즘을 제공해주는지 알아두시는 게 좋습니다. 코딩 테스트에서 사용된 프로그래밍 언어 중 C++과 Python에는 안정 정렬이 있고, Java와 JavaScript, Swift에는 안정 정렬이 없습니다. PHP 언어는 숫자 값을 고려해 정렬하는 &lt;a href=&quot;http://php.net/manual/en/function.natsort.php&quot;&gt;natsort()&lt;/a&gt;를 기본 함수로 제공하기도 합니다. (아쉽게도 문제 3과 조건이 달라 그대로는 쓸 수 없지만요.)&lt;/p&gt;

  &lt;p&gt;기본 정렬 함수가 안정 정렬을 지원하지 않거나, 이 문제처럼 비교 조건이 까다로운 경우에는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Schwartzian_transform&quot;&gt;decorate-sort-undecorate 패턴&lt;/a&gt;을 이용해서 쉽게 해결할 수도 있답니다.&lt;/p&gt;

  &lt;p&gt;이 문제의 정답률은 66.95%였습니다. 언어별로는 C++과 Python 사용자들이 힘들어했습니다. 안정 정렬을 지원해주는 언어인데 도움이 안 되었나 봅니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;문제4-방금그곡&quot;&gt;문제4. 방금그곡&lt;/h2&gt;
&lt;p&gt;라디오를 자주 듣는 네오는 라디오에서 방금 나왔던 음악이 무슨 음악인지 궁금해질 때가 많다. 그럴 때 네오는 다음 포털의 ‘방금그곡’ 서비스를 이용하곤 한다. 방금그곡에서는 TV, 라디오 등에서 나온 음악에 관해 제목 등의 정보를 제공하는 서비스이다.&lt;/p&gt;

&lt;p&gt;네오는 자신이 기억한 멜로디를 가지고 방금그곡을 이용해 음악을 찾는다. 그런데 라디오 방송에서는 한 음악을 반복해서 재생할 때도 있어서 네오가 기억하고 있는 멜로디는 음악 끝부분과 처음 부분이 이어서 재생된 멜로디일 수도 있다. 반대로, 한 음악을 중간에 끊을 경우 원본 음악에는 네오가 기억한 멜로디가 들어있다 해도 그 곡이 네오가 들은 곡이 아닐 수도 있다. 그렇기 때문에 네오는 기억한 멜로디를 재생 시간과 제공된 악보를 직접 보면서 비교하려고 한다. 다음과 같은 가정을 할 때 네오가 찾으려는 음악의 제목을 구하여라.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;방금그곡 서비스에서는 음악 제목, 재생이 시작되고 끝난 시각, 악보를 제공한다.&lt;/li&gt;
  &lt;li&gt;네오가 기억한 멜로디와 악보에 사용되는 음은 C, C#, D, D#, E, F, F#, G, G#, A, A#, B 12개이다.&lt;/li&gt;
  &lt;li&gt;각 음은 1분에 1개씩 재생된다. 음악은 반드시 처음부터 재생되며 음악 길이보다 재생된 시간이 길 때는 음악이 끊김 없이 처음부터 반복해서 재생된다.  음악 길이보다 재생된 시간이 짧을 때는 처음부터 재생 시간만큼만 재생된다.&lt;/li&gt;
  &lt;li&gt;음악이 00:00를 넘겨서까지 재생되는 일은 없다.&lt;/li&gt;
  &lt;li&gt;조건이 일치하는 음악이 여러 개일 때에는 라디오에서 재생된 시간이 제일 긴 음악 제목을 반환한다. 재생된 시간도 같을 경우 먼저 입력된 음악 제목을 반환한다.&lt;/li&gt;
  &lt;li&gt;조건이 일치하는 음악이 없을 때에는 “&lt;code class=&quot;highlighter-rouge&quot;&gt;(None)&lt;/code&gt;“을 반환한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;입력-형식-3&quot;&gt;입력 형식&lt;/h3&gt;
&lt;p&gt;입력으로 네오가 기억한 멜로디를 담은 문자열 &lt;code class=&quot;highlighter-rouge&quot;&gt;m&lt;/code&gt;과 방송된 곡의 정보를 담고 있는 배열 &lt;code class=&quot;highlighter-rouge&quot;&gt;musicinfos&lt;/code&gt;가 주어진다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;m&lt;/code&gt;은 음 &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;개 이상 &lt;code class=&quot;highlighter-rouge&quot;&gt;1439&lt;/code&gt;개 이하로 구성되어 있다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;musicinfos&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;100&lt;/code&gt;개 이하의 곡 정보를 담고 있는 배열로, 각각의 곡 정보는 음익이 시작한 시각, 끝난 시각, 음악 제목, 악보 정보가 ‘&lt;code class=&quot;highlighter-rouge&quot;&gt;,&lt;/code&gt;‘로 구분된 문자열이다.&lt;/li&gt;
  &lt;li&gt;음악의 시작 시각과 끝난 시각은 24시간 &lt;code class=&quot;highlighter-rouge&quot;&gt;HH:MM&lt;/code&gt; 형식이다.&lt;/li&gt;
  &lt;li&gt;음악 제목은 ‘&lt;code class=&quot;highlighter-rouge&quot;&gt;,&lt;/code&gt;’ 이외의 출력 가능한 문자로 표현된 길이 &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; 이상 &lt;code class=&quot;highlighter-rouge&quot;&gt;64&lt;/code&gt; 이하의 문자열이다.&lt;/li&gt;
  &lt;li&gt;악보 정보는 음 &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;개 이상 &lt;code class=&quot;highlighter-rouge&quot;&gt;1439&lt;/code&gt;개 이하로 구성되어 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;출력-형식-3&quot;&gt;출력 형식&lt;/h3&gt;
&lt;p&gt;조건과 일치하는 음악 제목을 출력한다.&lt;/p&gt;

&lt;h3 id=&quot;입출력-예시&quot;&gt;입출력 예시&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;m&lt;/th&gt;
      &lt;th&gt;musicinfos&lt;/th&gt;
      &lt;th&gt;answer&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;“ABCDEFG”&lt;/td&gt;
      &lt;td&gt;[“12:00,12:14,HELLO,CDEFGAB”, “13:00,13:05,WORLD,ABCDEF”]&lt;/td&gt;
      &lt;td&gt;“HELLO”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;“CC#BCC#BCC#BCC#B”&lt;/td&gt;
      &lt;td&gt;[“03:00,03:30,FOO,CC#B”, “04:00,04:08,BAR,CC#BCC#BCC#B”]&lt;/td&gt;
      &lt;td&gt;“FOO”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;“ABC”&lt;/td&gt;
      &lt;td&gt;[“12:00,12:14,HELLO,C#DEFGAB”, “13:00,13:05,WORLD,ABCDEF”]&lt;/td&gt;
      &lt;td&gt;“WORLD”&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;입출력-설명&quot;&gt;입출력 설명&lt;/h3&gt;
&lt;p&gt;첫 번째 예시에서 HELLO는 길이가 7분이지만 12:00부터 12:14까지 재생되었으므로 실제로 CDEFGABCDEFGAB로 재생되었고, 이 중에 기억한 멜로디인 ABCDEFG가 들어있다.
세 번째 예시에서 HELLO는 C#DEFGABC#DEFGAB로, WORLD는 ABCDE로 재생되었다. HELLO 안에 있는 ABC#은 기억한 멜로디인 ABC와 일치하지 않고, WORLD 안에 있는 ABC가 기억한 멜로디와 일치한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;문제-해설-3&quot;&gt;문제 해설&lt;/h3&gt;
  &lt;p&gt;부분 문자열 비교를 묻는 문제입니다. 하지만 멜로디의 각 음을 나타내는 글자가 한 글자일 수도 있고, 두 글자일 수도 있습니다. “ABC”라는 멜로디는 “ABCD”라는 악보에는 들어있지만, “ABC#”라는 악보에는 들어있지 않습니다. C#이 하나의 음을 이루고 있기 때문이죠.&lt;/p&gt;

  &lt;p&gt;문자열 비교에서 이런 문제를 처리해야 할 일이 있습니다. 
1차 코딩 테스트에서 설명했던 토큰화&lt;sup&gt;Tokenizing&lt;/sup&gt;를 통해 “ABC#”을 [“A”, “B”, “C#”] 식의 배열로 변환한 후에 비교를 수행할 수도 있고요. 아니면 두 글자로 된 “C#”, “D#”, “F#” 등을 악보에서 사용되지 않는 문자인 “c”, “d”, “e” 등으로 치환&lt;sup&gt;Substitution&lt;/sup&gt;한 후에 문자열 비교 함수를 이용할 수도 있습니다.&lt;/p&gt;

  &lt;p&gt;이 문제의 정답률은 47.50%였습니다. Python 사용자들이 가장 잘 풀었습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;문제5-자동완성&quot;&gt;문제5. 자동완성&lt;/h2&gt;
&lt;p&gt;포털 다음에서 검색어 자동완성 기능을 넣고 싶은 라이언은 한 번 입력된 문자열을 학습해서 다음 입력 때 활용하고 싶어 졌다. 예를 들어, &lt;code class=&quot;highlighter-rouge&quot;&gt;go&lt;/code&gt; 가 한 번 입력되었다면, 다음 사용자는 &lt;code class=&quot;highlighter-rouge&quot;&gt;g&lt;/code&gt; 만 입력해도 &lt;code class=&quot;highlighter-rouge&quot;&gt;go&lt;/code&gt;를 추천해주므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;o&lt;/code&gt;를 입력할 필요가 없어진다! 단, 학습에 사용된 단어들 중 앞부분이 같은 경우에는 어쩔 수 없이 다른 문자가 나올 때까지 입력을 해야 한다.
효과가 얼마나 좋을지 알고 싶은 라이언은 학습된 단어들을 찾을 때 몇 글자를 입력해야 하는지 궁금해졌다.&lt;/p&gt;

&lt;p&gt;예를 들어, 학습된 단어들이 아래와 같을 때&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;go
gone
guild
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;go&lt;/code&gt;를 찾을 때 &lt;code class=&quot;highlighter-rouge&quot;&gt;go&lt;/code&gt;를 모두 입력해야 한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gone&lt;/code&gt;을 찾을 때 &lt;code class=&quot;highlighter-rouge&quot;&gt;gon&lt;/code&gt; 까지 입력해야 한다. 
(&lt;code class=&quot;highlighter-rouge&quot;&gt;gon&lt;/code&gt;이 입력되기 전까지는 &lt;code class=&quot;highlighter-rouge&quot;&gt;go&lt;/code&gt; 인지 &lt;code class=&quot;highlighter-rouge&quot;&gt;gone&lt;/code&gt;인지 확신할 수 없다.)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;guild&lt;/code&gt;를 찾을 때는 &lt;code class=&quot;highlighter-rouge&quot;&gt;gu&lt;/code&gt; 까지만 입력하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;guild&lt;/code&gt;가 완성된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 경우 총 입력해야 할 문자의 수는 &lt;code class=&quot;highlighter-rouge&quot;&gt;7&lt;/code&gt;이다.&lt;/p&gt;

&lt;p&gt;라이언을 도와 위와 같이 문자열이 입력으로 주어지면 학습을 시킨 후, 학습된 단어들을 순서대로 찾을 때 몇 개의 문자를 입력하면 되는지 계산하는 프로그램을 만들어보자.&lt;/p&gt;

&lt;h3 id=&quot;입력-형식-4&quot;&gt;입력 형식&lt;/h3&gt;
&lt;p&gt;학습과 검색에 사용될 중복 없는 단어 &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;개가 주어진다. 
모든 단어는 알파벳 소문자로 구성되며 단어의 수 &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;과 단어들의 길이의 총합 &lt;code class=&quot;highlighter-rouge&quot;&gt;L&lt;/code&gt;의 범위는 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;2 &amp;lt;= &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; &amp;lt;= 100,000&lt;/li&gt;
  &lt;li&gt;2 &amp;lt;= &lt;code class=&quot;highlighter-rouge&quot;&gt;L&lt;/code&gt; &amp;lt;= 1,000,000&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;출력-형식-4&quot;&gt;출력 형식&lt;/h3&gt;
&lt;p&gt;단어를 찾을 때 입력해야 할 총 문자수를 리턴한다.&lt;/p&gt;

&lt;h3 id=&quot;입출력-예제-3&quot;&gt;입출력 예제&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;words&lt;/th&gt;
      &lt;th&gt;result&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;[“go”,”gone”,”guild”]&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[“abc”,”def”,”ghi”,”jklm”]&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;[“word”,”war”,”warrior”,”world”]&lt;/td&gt;
      &lt;td&gt;15&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;입출력-설명-1&quot;&gt;입출력 설명&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;첫 번째 예제는 본문 설명과 같다.&lt;/li&gt;
  &lt;li&gt;두 번째 예제에서는 모든 단어들이 공통된 부분이 없으므로, 가장 앞글자만 입력하면 된다.&lt;/li&gt;
  &lt;li&gt;세 번째 예제는 총 &lt;code class=&quot;highlighter-rouge&quot;&gt;15&lt;/code&gt; 자를 입력해야 하고 설명은 아래와 같다.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;word&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;word&lt;/code&gt; 모두 입력해야 한다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;war&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;war&lt;/code&gt; 까지 모두 입력해야 한다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;warrior&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;warr&lt;/code&gt; 까지만 입력하면 된다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;world&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;worl&lt;/code&gt;까지 입력해야 한다. (&lt;code class=&quot;highlighter-rouge&quot;&gt;word&lt;/code&gt;와 구분되어야 함을 명심하자)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;문제-해설-4&quot;&gt;문제 해설&lt;/h3&gt;
  &lt;p&gt;3차 코딩 테스트에서 가장 어려운 문제였습니다. 열심히 코딩한 후에 제출하면 시간 제한에 걸려 좌절하는 지원자가 많았습니다. 두 단어 “world”와 “word”가 앞 세 글자가 겹친다는 걸 찾는 건 어렵지 않지만, 모든 단어 쌍을 비교하는 방식으로는 제한 시간 내에 풀 수 없습니다.&lt;/p&gt;

  &lt;p&gt;이 문제 해결에 적합한 자료 구조로 트라이&lt;sup&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Trie&quot;&gt;Trie&lt;/a&gt;&lt;/sup&gt;가 있습니다. 입력으로 주어진 단어로 트라이를 구성하면, 같은 접두어&lt;sup&gt;Prefix&lt;/sup&gt;를 갖는 단어가 얼마나 있는지를 효과적으로 찾을 수 있습니다.&lt;/p&gt;

  &lt;p&gt;또 다른 방법이 하나 더 있는데요. 전체 단어를 사전 순으로 정렬한다면, 어떤 단어와 앞부분이 가장 많이 일치하는 단어는 정렬 후 인접한 두 단어 중 하나가 됩니다. 이 방법을 이용하면 모든 단어 쌍이 아닌, 정렬 후에 인접한 단어 쌍만 비교하면 되므로 빠르게 문제를 해결할 수 있습니다.&lt;/p&gt;

  &lt;p&gt;이 문제의 정답률은 34.07%였습니다. Java 사용자들이 가장 잘 풀었습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;필기-시험&quot;&gt;필기 시험&lt;/h1&gt;
&lt;p&gt;아마, 많은 지원자 분들이 필기 시험이 등장하여 적잖이 당황스러우셨을 겁니다. 알고리즘을 묻는 코딩 테스트 만으로는 자칫 채용 시험이 코딩 대회의 장이 될 수 있어 이를 보완하고자 기본 지식을 묻는 필기 시험을 추가하기로 했습니다. 필기 시험이 있다는 사실은 당일까지도 공지하지 않고 대외비로 준비했는데요. 대신 사전 학습 없이도 평소에 컴퓨터 과학을 공부했다면 누구나 쉽게 풀 수 있는, 상식 수준에 준하는 문제들로 출제하였습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;/files//kakao-blind-recruitment.pdf&quot;&gt;필기 시험 PDF 다운로드&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;문제는 총 20문제로 구성하였습니다.&lt;/p&gt;

&lt;p&gt;이 중 10번까지는 빈칸을 채우는 문제였습니다. 컴퓨팅 및 컴퓨터 과학, 인터넷 등의 기본적인 개념에 대한 영어 위키백과의 설명을 제시하고 각각 무엇을 설명하는 지를 맞추는 문제였습니다.&lt;/p&gt;

&lt;p&gt;현업에서 일을 하려면 평소에도 영어로 된 문서를 많이 접하게 될 텐데요. 따라서 문제 또한 모두 영어로 제시하여 독해 능력도 함께 보고자 했고, 각각의 문항 앞뒤로 충분한 부연 설명을 제시하여 최소한 이 정도 용어는 알고 있으면 좋겠다는 출제 의도를 포함했습니다.&lt;/p&gt;

&lt;p&gt;사실 이 문제들은 문장을 검색해보면 금방 정답을 찾을 수 있습니다. 그러나, 검색 없이도 이 정도 용어들은 바로 대답할 수 있길 바랬고, 인터넷이 제한된 오프라인 테스트여서 가능한 문제들이었습니다.&lt;/p&gt;

&lt;p&gt;11번은 조금 어려운 문제였던 거 같습니다. TCP의 커넥션 종료 과정의 순서를 묻는 문제였는데요.  순서보다 좀 더 정확히는 active close와 passive close를 숙지하고 있는지를 묻고 싶었습니다.
실무에서 TIME_WAIT으로 인한 문제는 여전히 간간히 발생하고 있으므로 이 개념은 꼭 숙지했으면 하는 의도로 출제하였습니다.
더 깊은 이야기는 카카오 기술 블로그에 올라왔던 &lt;a href=&quot;http://tech.kakao.com/2016/04/21/closewait-timewait/&quot;&gt;CLOSE_WAIT &amp;amp; TIME_WAIT 최종 분석&lt;/a&gt; 글을 읽어보세요.&lt;/p&gt;

&lt;p&gt;12번은 제록스 팔로알토 연구소에서 1979년에 소개한, 소프트웨어 구조를 설명한 사실상 최초의 방법론이자 여전히 중요하게 쓰이고 있는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Model–view–controller&quot;&gt;MVC 소프트웨어 디자인 패턴&lt;/a&gt;에 대한 문제입니다.&lt;/p&gt;

&lt;p&gt;13, 14, 15번 문제는 시간 복잡도, 빅오를 구하는 문제였는데요. 13번의 경우 실행 순서를 손으로 그려본다면 2&lt;sup&gt;n&lt;/sup&gt;이 됨을 알 수 있습니다. 14, 15번은 상수항이 있는데요. 빅오에서는 일반적으로 상수항을 제거하기 때문에 각각 n이 됩니다. 특히 14번의 경우 ½ n이 되는데, 이는 log n과 혼동할 수 있으나 엄연히 전혀 다릅니다. 따라서 상수항 ½ 이 제거되어 n이 됩니다.&lt;/p&gt;

&lt;p&gt;16번은 재밌는 문제인데요. 약간의 함정이 숨어 있는데 각각의 시간 복잡도를 계산해보면, len(A) = N, len(B) = M 이라 할 때, A를 정렬할 경우 정렬과 이진 검색을 합하면 N log N + M log N = (N+M) log N, B를 정렬할 경우 M log M + N log M = (N+M) log M 이 됩니다. 길이가 짧은 A를 정렬하는 쪽이 좀 더 빠르게 동작하겠죠?&lt;/p&gt;

&lt;p&gt;17, 18, 19번은 적합한 자료 구조를 묻는 문제였고 어렵지 않게 풀 수 있었으리라 생각합니다. 18번의 경우 위키백과에도 인덱스 구현에 대한 설명&lt;sup&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Database_index#Index_implementations&quot;&gt;참고&lt;/a&gt;&lt;/sup&gt;이 등장합니다. 인기 있는 인덱스 구현  자료구조는 균형 트리, B+ 트리, 해시라고 나오네요.&lt;/p&gt;

&lt;p&gt;20번은 트리 순회를 직접 계산해보는 문제입니다. 알고리즘을 설명에 상세히 제시하였기 때문에 기존에 트리 순회 알고리즘을 몰랐던 분들도 충분히 쉽게 풀 수 있었으리라 생각합니다.&lt;/p&gt;

&lt;h1 id=&quot;마무리하며&quot;&gt;마무리하며&lt;/h1&gt;
&lt;p&gt;코딩 테스트 참가자들의 메일이나 후기로 블라인드 테스트에 대한 많은 의견들을 들을 수 있었습니다. 1차 코딩 테스트 후기에서 언급되었던 것처럼 채용을 위한 시험이기에  이번 세 차례의 블라인드 테스트는 어려운 문제보다는 기본기를 확인하기 위한 기본적인 문제 중심으로 출제했으며, 실무에서 접할 수 있을법한 문제 중심으로 구성했습니다.&lt;/p&gt;

&lt;p&gt;세 차례의 코딩 테스트를 통과한 지원자들은 이제 또다시 두 차례의 면접이 기다리고 있습니다. 코딩 테스트를 통해 다양한 방식으로 개발 역량을 검증했다면, 면접은 카카오에서 함께 일할 수 있는 사람인지를 확인하는 과정입니다. 카카오 크루로 함께 일할 수 있게 되길 기대해보겠습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;함께 보기:&lt;/strong&gt;&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http://tech.kakao.com/2017/08/30/employment/&quot;&gt;카카오 블라인드 신입 개발자 공채를 실시합니다!&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://tech.kakao.com/2017/09/27/kakao-blind-recruitment-round-1/&quot;&gt;카카오 신입 공채 1차 코딩 테스트 문제 해설&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://tech.kakao.com/2017/10/24/kakao-blind-recruitment-round-2/&quot;&gt;카카오 신입 공채 2차 코딩 테스트 문제 해설&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Tue, 14 Nov 2017 11:20:00 +0900</pubDate>
        <link>http://localhost:8080/kakao-blind-recruitment-round-3/</link>
        <guid isPermaLink="true">http://localhost:8080/kakao-blind-recruitment-round-3/</guid>
        
        <category>kakao</category>
        
        <category>recruitment</category>
        
        
      </item>
    
      <item>
        <title>카카오 신입 공채 2차 코딩 테스트 문제 해설</title>
        <description>&lt;p&gt;지난 10월 14일(토) 오후 2시부터 10시까지 8시간 동안 온라인 2차 코딩 테스트가 있었습니다. 1차 코딩 테스트와도 사뭇 다른 형식이라 신선했다는 의견도 있고, 당황한 지원자도 있었을 텐데요. 2차 문제에는 어떤 의도가 숨어있는지 살펴보겠습니다.&lt;/p&gt;

&lt;h1 id=&quot;추가적으로-어떤-테스트를-해야할까&quot;&gt;추가적으로 어떤 테스트를 해야할까?&lt;/h1&gt;
&lt;p&gt;1차 코딩 테스트는 어려운 알고리즘 문제가 아닌 자료구조, 알고리즘 등의 전산학 기초에 대해 충분히 학습하였다면 누구나 풀 수 있을만한 “구현” 위주의 문제들로 구성을 하였고, 총 7문제 중 4문제 이상 푼 지원자들에게 2차 기회가 주어졌습니다. 즉, 기본적인 구현 역량은 보유하고 있다고 할 수 있습니다. 그렇다면 추가적으로 테스트 해야하는 것은 무엇일까요?&lt;/p&gt;

&lt;p&gt;온라인 2차 코딩 테스트 문제 출제 위원회에서는,&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;탄탄한 기본기를 바탕으로 새로운 것을 빠르게 습득하는 역량&lt;/li&gt;
  &lt;li&gt;요구사항을 꼼꼼하게 분석하고, 트레이드오프를 감안하여 디자인하여 구현하는 역량&lt;/li&gt;
  &lt;li&gt;결과를 모니터링하며 점진적으로 개선해나가는 역량
을 테스트할 수 있도록 2차 문제에 녹여내고자 하였습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;문제에 어떤 장치들이 있었는지 살펴볼까요?&lt;/p&gt;

&lt;h1 id=&quot;이미지-특징값을-수집하는-crawler-구현&quot;&gt;이미지 특징값을 수집하는 Crawler 구현&lt;/h1&gt;
&lt;h2 id=&quot;rest-api-json-parsing을-이용하라&quot;&gt;REST API, JSON Parsing을 이용하라!&lt;/h2&gt;

&lt;p&gt;2차 테스트 문제는 우선 토큰을 발급받고, 웰컴 서버로부터 5개 카테고리의 Seed URL을 받아온 후 각 카테고리의 문서를 읽어 그 안에 있는 이미지들을 가져와 특징값을 추출하여 서버에 저장/삭제하는 문제입니다.&lt;/p&gt;

&lt;p&gt;쉽게 구현할 수 있는 수준의 요구사항을 주되, 자주 접해보지 않았을 (것으로 추정되는) REST API와 JSON Parsing을 포함시켜 단 시간에 학습하여 풀도록 하였습니다. 이 두가지 키워드는 언어별 편차가 심한 점을 감안하여 사전에 미리 제공하였습니다.&lt;/p&gt;

&lt;h2 id=&quot;반복적인-모니터링과-최적화를-유도-제한된-토큰-유효시간&quot;&gt;반복적인 모니터링과 최적화를 유도: 제한된 토큰 유효시간&lt;/h2&gt;
&lt;p&gt;토큰의 유효기간은 10분으로 설정하고, 점수 현황판을 제공했습니다. 8시간 동안 스스로 최적화를 하고 한 번만 결과를 제출하도록 하면 일부 지원자는 반복 과정을 통해 최적화를 하지 않을 것 같았습니다. 그래서 다른 사람의 점수를 보고 계속해서 최적화를 수행할 수 있도록 토큰을 10분으로 제한하였습니다. 수행하는 도중에 문제점이나 병목을 찾으려면 적절히 로그도 남겨야 하고 모니터링도 자연스럽게 하게 될 것이라 생각했습니다.&lt;/p&gt;

&lt;h2 id=&quot;전략수립은-평가-메트릭-분석부터&quot;&gt;전략수립은 평가 메트릭 분석부터!&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;기호&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
      &lt;th&gt;가중치&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;A&lt;/td&gt;
      &lt;td&gt;정상 저장된 이미지 수&lt;/td&gt;
      &lt;td&gt;1.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;B&lt;/td&gt;
      &lt;td&gt;저장되지 않고 누락된 이미지 수&lt;/td&gt;
      &lt;td&gt;-0.8&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;C&lt;/td&gt;
      &lt;td&gt;삭제되지 않고 남아있는 이미지 수&lt;/td&gt;
      &lt;td&gt;-1.2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;D&lt;/td&gt;
      &lt;td&gt;잘못된 데이터 수&lt;/td&gt;
      &lt;td&gt;-3.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;E&lt;/td&gt;
      &lt;td&gt;총 쿼리양&lt;/td&gt;
      &lt;td&gt;-0.01&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;최종점수는 아래 공식으로 산출합니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;max(0, 1.0 * A - 0.8 * B - 1.2 * C - 3.0 * D) + 512 - 0.01 * E&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;평가 메트릭은 최대한 현실적인 부분을 반영하려고 노력했습니다.&lt;/p&gt;

&lt;p&gt;누락되거나 삭제되지 않은 이미지에는 페널티를 부여하였는데, 누락보다는 삭제되지 않은 경우에 더 큰 페널티를 주었습니다. 이는 실 상황을 더 반영한 것인데, 누락된 것보다는 삭제되지 않은 이미지가 더 치명적이기 때문입니다. 사용자에게 노출되지 말아야 할 이미지가 삭제되지 않고 노출된 것이, 노출되었으면 좋았을 이미지가 누락되어 노출되지 않은 것보다는 더 치명적일테니까요. 마찬가지로 잘못된 데이터의 경우 페널티가 가장 큽니다. 데이터가 잘못된 경우 시스템을 서서히 망가뜨리는 데다가, 이를 알아차리기가 쉽지 않기 때문입니다.&lt;/p&gt;

&lt;p&gt;총 쿼리 수에 마이너스 페널티를 준 것은 적절히 요청하지 않아도 되는 것들을 필터링하라는 의도가 반영되었습니다.&lt;/p&gt;

&lt;h2 id=&quot;고득점을-하려면-병렬-처리를&quot;&gt;고득점을 하려면 병렬 처리를!&lt;/h2&gt;
&lt;p&gt;가장 빈번하게 호출해야 하는 API는 /image/feature입니다. 해당 API의 웰컴 서버에서의 처리 속도는 요청하는 개수에 따라 약 최소 16ms ~ 최대 120ms 까지 걸리도록 디자인하였습니다. 네트워크 지연 시간을 포함하면 싱글 스레드로는 초당 요청 제한인 50건을 채우지 못할 수 있습니다. 따라서 스레드 혹은 프로세스를 최소 2개 이상 생성해야 초당 요청 수 제한을 상회할 수 있습니다.&lt;/p&gt;

&lt;p&gt;참고로 웰컴 서버 처리 속도는 배치 처리 개수에 따라 exp 그래프 형태를 취하고 있습니다. 최대 배치 처리 사이즈인 50개씩 보내는 것보다 30~40개 정도가 가장 효율이 좋도록 설계되어 있습니다. 대다수의 지원자가 단건, 혹은 50개씩 요청을 보냈는데, 30개씩 보낸 지원자도 있어 놀랐습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://t1.kakaocdn.net/welcome2018/round2_batch.png&quot; alt=&quot;배치 처리 개수에 따른 응답 시간&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;예외처리는-필수&quot;&gt;예외처리는 필수&lt;/h2&gt;
&lt;p&gt;실제 이미지 크롤링을 한다고 생각해봅시다. 크롤링하려고 URL을 큐에 넣어두었는데 그 사이 사용자가 이미지를 삭제했을 수도 있고, 해당 서버가 잠시 내려갔을 수도 있습니다. 웰컴 서버도 이를 시뮬레이션했습니다. 모든 API는 특정 확률 값에 따라 실패하도록 되어 있습니다. 그리고 특정 이미지는 특징값 추출이 매번 실패하도록 고안되었습니다. 재시도 예외처리를 하지 않았다면 해당 요청은 누락되어 감점이 될 것이고, 반복적으로 특징값 추출에 실패하는 이미지를 블록처리하지 않았다면 무의미한 요청이 쌓여 페널티를 받게 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;다양한-시나리오에-대응하라&quot;&gt;다양한 시나리오에 대응하라!&lt;/h2&gt;
&lt;p&gt;문서 내 이미지들의 추가/삭제 간에는 다양한 시나리오가 존재합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;정상적으로 추가 혹은 삭제되는 경우&lt;/li&gt;
  &lt;li&gt;이미 기존에 추가한 이미지를 또 추가하는 경우&lt;/li&gt;
  &lt;li&gt;방금 추가한 이미지를 바로 삭제하는 경우&lt;/li&gt;
  &lt;li&gt;추가된 적 없는 이미지를 삭제하라고 오는 경우&lt;/li&gt;
  &lt;li&gt;추가, 삭제, 추가가 연달아 오는 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;모두 현실에 있을 법한 유형들입니다. 보통 인터넷에는 아주 많은 중복 이미지가 존재하고, 이 모든 이미지를 색인하다면 공간 낭비가 크기 때문에, 기존에 이미 추가된 이미지인지 확인하는 단계가 필요합니다. 우리의 온라인 테스트에서는 간단한 메모리 캐시로도 충분합니다. 한 문서 내에 추가/삭제 명령이 연달아 오는 경우도 있습니다. 이 경우에는 웰컴 서버에 추가했다가 삭제할 것이 아니라 서로 상쇄시키면 불필요한 API 요청을 줄일 수 있습니다. 추가된 적 없는 이미지를 삭제하라고 오는 경우도 있습니다. 이 경우도 메모리 캐시를 사용하고 있다면 쉽게 걸러낼 수 있습니다. 마지막 경우는 추가/삭제를 상쇄하는 연산을 할 때 단순히 set을 사용하면 안 되도록 넣어두었습니다. Add A, Del A, Add A 가 올 경우 최종적으로 Add A 만 요청해야 하는데, set으로 합쳐버리면 Add A, Del A 만 남아서 서로 상쇄되어 누락될 것 입니다.&lt;/p&gt;

&lt;p&gt;여기서 한 가지 더, 이미지 추가/삭제는 문서 전 영역에 걸쳐 일어납니다. 즉 첫 번째 문서에서 추가한 이미지를 50번째 문서에서 삭제할 수 있습니다. 따라서 50건이 쌓일 때마다 추가/삭제 연산을 요청한 지원자의 경우 이미지 누락을 피할 수 없습니다. 그렇다고 계속 쌓아두다가 막판에 넣으려 하다보면 제한 시간 10분을 초과하여 이미지를 다 넣지 못하는 사태가 생길 수도 있지요. 적절한 선에서 의사결정을 해야 합니다. (트레이드오프)&lt;/p&gt;

&lt;h2 id=&quot;총-5개의-카테고리&quot;&gt;총 5개의 카테고리&lt;/h2&gt;
&lt;p&gt;이 곳에도 장치가 마련되어 있습니다. 카테고리별로 이미지의 추가/삭제 비율과 next_url 이 갱신되는 시간에 차등이 있습니다. 시시각각 업데이트되는 news 카테고리 같은 경우 next_url 이 매우 빈번하게 갱신이 됩니다. 반면 art 카테고리는 상대적으로 next_url 이 업데이트 안 될 확률이 7~8배 높습니다. 이미지 데이터량 자체는 blog 카테고리가 가장 풍부합니다. 다만 유저가 올리는 만큼 삭제되는 이미지도 많고, 추가했다가 삭제하는 등의 변동도 가장 크도록 설계되었습니다. 반면 정제된 news는 추가/삭제는 큰 반면 변동은 적습니다.&lt;/p&gt;

&lt;p&gt;실제 내부 베타 테스트 진행 시 30만 점을 획득한 한 카카오 개발자는 5개의 카테고리 중 2개는 제외하고 3개 카테고리만 수집하여 30만점 이상의 고득점을 올렸습니다. 이번 온라인 2차 테스트에서도 일부 지원자가 카테고리 1개씩만 시도하는 경우가 발견되었습니다. 단, 여기에도 물론 트레이드오프가 존재합니다. 1개 카테고리만 수집한다고 할 경우 병렬 처리를 하게 되면 문서 간 순서를 보장하는 것이 어려워집니다. 추가적인 구현이 필요하거나 혹은 순서가 뒤틀림에 따라 받게 되는 누락 페널티를 무시하고 양으로 승부할 수도 있겠지요. 다시 한 번, 모든 것이 다 트레이드오프입니다.&lt;/p&gt;

&lt;h2 id=&quot;마치며&quot;&gt;마치며&lt;/h2&gt;
&lt;p&gt;여러분은 어느 정도까지 파악하여 진행하셨나요?&lt;/p&gt;

&lt;p&gt;합격선은 8만 점으로 병렬 처리를 하지 않았더라도 예외처리를 하고, 배치 처리를 했다면 충분히 받을 수 있는 점수이지만, 문제출제위원회는 이렇게 다양하게 장치를 마련해두었고, 또 이런 장치들이 실무에서도 흔하게 발생하는, 그래서 여러분들이 앞으로 고민할 수도 있는 트레이드오프였다는 것을 이야기하고 싶습니다.&lt;/p&gt;

&lt;p&gt;오랜 시간 고생하셨습니다!&lt;/p&gt;

&lt;h1 id=&quot;대회-이모저모&quot;&gt;대회 이모저모&lt;/h1&gt;

&lt;h2 id=&quot;언어별-통계&quot;&gt;언어별 통계&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://t1.kakaocdn.net/welcome2018/round2_language.png&quot; alt=&quot;합격자의 언어 사용 현황&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2차 합격자들의 언어 분포입니다. 1차 테스트에서는 C++가 25%로 가장 높았으나 2차 테스트에서는 파이썬이 42.1%로 압도적으로 높은 비율을 보였고, 자바가 35.1% 로 뒤를 이었습니다. 1차에서는 테스트 플랫폼의 제약 때문에 보이지 않던 C#, Objective-C도 보이고요. 차트에는 보이지 않지만, Go로 푼 지원자도 1명 있었습니다.&lt;/p&gt;

&lt;h2 id=&quot;점수-분포&quot;&gt;점수 분포&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://t1.kakaocdn.net/welcome2018/round2_score.png&quot; alt=&quot;최종점수 구간별 비율&quot; /&gt;&lt;/p&gt;

&lt;p&gt;최고점은 235,969점이며 응시자 전체 평균은 47,705점입니다.&lt;/p&gt;

&lt;p&gt;대략적인 코드 분석 결과는 아래와 같습니다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;병렬처리&lt;/th&gt;
      &lt;th&gt;배치처리&lt;/th&gt;
      &lt;th&gt;예외처리&lt;/th&gt;
      &lt;th&gt;최종점수&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;X&lt;/td&gt;
      &lt;td&gt;X&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;5만점 내외&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;X&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;14만점 내외&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;O&lt;/td&gt;
      &lt;td&gt;25만점 내외&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;트래픽&quot;&gt;트래픽&lt;/h2&gt;
&lt;p&gt;2차 온라인 코딩테스트를 준비하면서 가장 심혈을 기울인 부분은 “트래픽 테스트” 입니다. 서버와 통신을 주고받는 형태이다 보니 서버의 응답이 느려지거나 자칫 서버가 죽기라도 한다면 테스트에 치명적이기 때문입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://t1.kakaocdn.net/welcome2018/round2_traffic.png&quot; alt=&quot;초과 요청 및 요청량 그래프&quot; /&gt;&lt;/p&gt;

&lt;p&gt;우선 일차적으로 토큰별 요청량은 초당 50개로 제한하였습니다. 첫 번째 그래프가 같은 토큰으로 초당 50개 이상씩 던지는 사용자의 요청을 Drop 한 결과입니다. 한 개의 토큰으로 최고 800개/초 요청을 보낸 지원자도 있습니다.&lt;/p&gt;

&lt;p&gt;스트레스 테스트는, 예상 트래픽을 산출(700여 명의 지원자 * 초당 50건 = 35,000건/초)한 후 약 2~3배의 트래픽에도 문제 없을 정도로 준비하였습니다. 다행스럽게도, 초당 트래픽의 최고치는 약 6000건으로 문제 없이 테스트를 치를 수 있었습니다.&lt;/p&gt;

&lt;h2 id=&quot;이슈&quot;&gt;이슈&lt;/h2&gt;
&lt;p&gt;2차 코딩테스트 진행 도중 두 가지 이슈가 있었습니다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;크로스 도메인(cross domain) 문제
    &lt;ul&gt;
      &lt;li&gt;웹브라우저 환경에서 자바스크립트를 사용해 문제를 풀려고 시도한 지원자들이 크로스 도메인 문제에 막혀 한동안 서버에 접근할 수 없는 문제가 있었습니다. 웰컴 서버에 CORS(&lt;a href=&quot;http://en.wikipedia.org/wiki/Cross-origin_resource_sharing&quot;&gt;Cross Origin Resource Sharing&lt;/a&gt;)를 활성화해 해결하였습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Non-minified JSON 파싱 문제
    &lt;ul&gt;
      &lt;li&gt;Feature Save/Delete API의 request body가 minified JSON 형태가 아닌 경우 일부 채점이 안되는 문제가 있었습니다. 테스트 종료 후 전수 검사를 통해 해당되는 지원자들은 불이익이 없도록 조치를 취했습니다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;매끄럽게 진행하지 못하여 불편을 겪으신 일부 지원자분들께 양해 말씀드립니다.&lt;/p&gt;
</description>
        <pubDate>Tue, 24 Oct 2017 10:00:00 +0900</pubDate>
        <link>http://localhost:8080/kakao-blind-recruitment-round-2/</link>
        <guid isPermaLink="true">http://localhost:8080/kakao-blind-recruitment-round-2/</guid>
        
        <category>kakao</category>
        
        <category>recruitment</category>
        
        
      </item>
    
      <item>
        <title>분산 웹 캐시 (Wcache)의 개선과정 - Part 2</title>
        <description>&lt;h1 id=&quot;overview&quot;&gt;Overview&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;/2017/10/23/wcache-1/&quot;&gt;Part 1: 분산 웹 캐시&lt;/a&gt;에서는 카카오의 트래픽을 처리하고 있는 Wcache에 대한 간략한 소개를 하였습니다.
이전 버전의 Wcache는 기본적으로 준수한 응답속도를 보이고 있었지만, metadata를 집중된 DB에 저장하는 방식 및 기타 구조상의 문제로 인한 성능 안정성 문제,
그리고 기능상의 문제들이 잠재되어 있었습니다. 본 포스트에서는 이전 버전의 Wcache에서 어떠한 구조적 문제가 있었는지, 또한 이를 어떻게 해결하였는지를 다룹니다.&lt;/p&gt;

&lt;h1 id=&quot;part-2-wcache-저장-구조-변경&quot;&gt;Part 2: Wcache 저장 구조 변경&lt;/h1&gt;

&lt;h2 id=&quot;저장-구조-변경---성능-안정화&quot;&gt;저장 구조 변경 - 성능 안정화&lt;/h2&gt;
&lt;h3 id=&quot;기존-bigfile-저장방식의-문제점&quot;&gt;기존 BigFile 저장방식의 문제점&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;/2017/10/23/wcache-1/&quot;&gt;이전 포스트&lt;/a&gt;에 나와있듯이 Wcache는 metadata 정보를 컨텐츠와는 별도로 DB에 저장해 두고 있었습니다. 메모리에
올라와 있는 LRU hashtable에 원하는 컨텐츠가 캐싱되어 있지 않다면, SQLite DB에 컨텐츠 키를 가지고 어떤 BigFile에 있는지, 헤더의 길이는 얼마나 되는지 등의 정보들을 조회를 해야 하는 것이죠.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/wcache-storage-before.png&quot; alt=&quot;메모리 상의 LRU hashtable에 없을 경우 기존 Wcache의 컨텐츠 조회 방식&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 과정은 평상시 읽는 과정에서는 문제가 없었지만, block 단위로 컨텐츠를 디스크에 저장할 때와 BigFile이 가득 차 오래된 BigFile block들을 replace 할 때 문제가 발생합니다.
n개의 컨텐츠가 하나의 block에 있을 경우 BigFile에서의 디스크 write operation은 한 번만 발생하지만 SQLite DB에서의 metadata 관련 정보 업데이트는 n번 발생하게 됩니다. 
특히, 주기적으로 용량 확보를 위해 오래된 블록 또는 BigFile 전체를 비워야 하는 경우,
DB 전체를 스캔해 관련 항목을 삭제하는 작업(ex: &lt;em&gt;“DELETE FROM table WHERE BigFileNo = 1”&lt;/em&gt;)으로 인한 부하가 증가하게 되고,
결국 이러한 작업이 있을 때마다 Wcache의 성능은 일시적으로 평상시에 비해 최대 80%까지 하락하는 모습을 보이게 됩니다.
DB 부하를 줄이기 위해 block 크기를 줄이는 방법을 고려해 보았으나 그만큼 디스크 write operation 횟수가 증가합니다.
게다가 구조상 block 크기보다 큰 컨텐츠를 저장할 수 없기 때문에 그만큼 캐시 효율이 감소하게 됩니다.&lt;/p&gt;

&lt;p&gt;이러한 중앙 집중적인 SQLite구조에는 한계가 있다고 파악하였고, 근본적으로 저장 구조를 개선해야 된다고 결론 내렸습니다.&lt;/p&gt;

&lt;h3 id=&quot;journaling-bigfile-jbf&quot;&gt;Journaling BigFile (JBF)&lt;/h3&gt;
&lt;p&gt;중앙 집중적인 SQLite대신 각 BigFile에 metadata를 함께 저장하는 방식을 취하기로 하였습니다.
이를 위해 SQLite처럼 journaling이 가능하면서 안정적으로 metadata와 컨텐츠를 저장하기 위해 자체적으로 Journaling BigFile, 일명 JBF를 개발해 적용하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/jbf.png&quot; alt=&quot;JBF의 구조도. 포맷을 위해서는 앞부분(전체 파일 크기의 1%)만 리셋해주면 된다.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;JBF는 위 그림과 같이 BigFile 내부에 block-level journal(write-ahead log), space map, B-Tree 등을 가지고 있어 BigFile 개별로 복구, 조회, 포맷이 가능합니다.
또한, Metadata 정보를 JBF 내부 B-Tree에 적재하고, 컨텐츠 body는 JBF의 일반 영역에 저장합니다.
JBF는 BigFile별 포맷이 매우 빠르게 이루어 지기 때문에 기존 버전과는 다르게 가득 찬 BigFile을 비울 때 발생하는 성능 하락 이슈가 없습니다.
컨텐츠를 여러 block에 걸쳐 쓰는것이 가능하기 때문에 저장 가능한 컨텐츠의 최대 크기 제한 역시 BigFile 전체 크기로 늘어나게 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;jbf를-이용한-저장구조&quot;&gt;JBF를 이용한 저장구조&lt;/h3&gt;
&lt;p&gt;기존 SQLite에 의존했던 탐색 로직을 개편하기 위해서는 어떠한 JBF에 컨텐츠가 존재하는지를 캐시 key 만으로 알아내야 합니다.
이를 위해 JBF들을 몇 개의 그룹으로 나누고, 캐시 key를 그룹 개수로 modular 연산하여 특정 그룹을 정하고, 해당 그룹 내부의 있는 JBF들에서 순차적으로 탐색하도록 구성하였습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/wcache-storage-after.png&quot; alt=&quot;JBF를 적용한 Wcache의 컨텐츠 조회 방식. Read시에는 최근에 write한 JBF부터 조회한다.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;전체 JBF들을 동시에 사용하지 않고 그룹으로 묶어 사용하는 이유는 효율적인 디스크 용량 활용이 가능해지기 때문입니다. 
JBF는 BigFile 단위로 포맷을 하게 되는데, 그룹을 만들지 않고 모든 JBF에 골고루 저장하게 되면 JBF들이 가득 차게 되는 시점이 비슷해지고, 
이후 오래된 캐시를 비우는 작업 시 전체 JBF들을 비슷한 시기에 비워야 하는 이슈가 생깁니다. 
그렇게 되면 순간적으로 hit율이 낮아짐은 물론 새롭게 컨텐츠를 캐싱하는 양도 많아져 소스 서버의 부하까지 발생하게 됩니다. 
반면 그룹을 묶어서 사용하게 되면 그룹 별로 하나씩만 비울 수 있게 되어 순간적인 캐시 hit율 하락을 완화시킬 수 있습니다.&lt;/p&gt;

&lt;p&gt;또한 각 그룹별로 write가 이루어지는 JBF들의 순번이 정해져 있고 컨텐츠가 쌓이는 속도도 일정하기 때문에 이점을 활용해 디스크 locality도 증가시킬 수 있습니다.
Wcache 초기 세팅 시 각 그룹에서 같은 순번에 있는 JBF들을 물리적 디스크상에서 인접하게 생성시키면(group 1의 1번 JBF, group 2의 1번 JBF, … group 1의 2번 JBF, …)
컨텐츠를 디스크에 캐싱할 때 인접한 구역을 쓰기 때문에 HDD를 사용하는 경우 디스크의 seek time을 줄일 수 있는 중요한 요인이 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;bloom-filter를-통한-jbf-성능-최적화&quot;&gt;Bloom filter를 통한 JBF 성능 최적화&lt;/h3&gt;

&lt;p&gt;JBF들의 그룹을 만드는 구조는 한 가지 치명적인 단점이 있습니다. 바로 중복된 JBF 탐색입니다. 위 그림에서 볼 수 있듯이 캐싱된지 오래된 컨텐츠를 읽기
위해서는 쓸모없는 JBF 탐색이 들어가야 하는데, 이는 개편 후 초기 테스트 시 Wcache에 쌓이는 컨텐츠가 많아질수록 성능을 저하시키는 주요 원인이 되었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/bloom-filter.png&quot; alt=&quot;Bloom filter 도식도. n번의 hash를 돌린 결과값이 전부 bucket에 존재하면 통과, 하나라도 없으면 실패. (출처: Wikipedia)&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이를 해결하기 위해 각 JBF 앞단에 bloom filter&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;를 적용하게 됩니다. Bloom filter는 어떤 원소가 집합에 속하였는지 확률적으로 알 수 있게 하는 함수입니다.
약간의 false positive만 가지고 있고 false negative는 없기 때문에 해당 필터를 통과하는 경우에만 JBF 조회를 하도록 변경을 함으로써 기존 대비 2 ~ 5배의 응답속도를 향상시켰습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/wcache-bloom-stat.png&quot; alt=&quot;Bloom filter를 적용한 경우와(주황색) 적용하지 않은 경우(파란색)의 응답속도 차이.&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;metadata-저장구조-변경---vary-object-관리-개선&quot;&gt;Metadata 저장구조 변경 - Vary Object 관리 개선&lt;/h2&gt;
&lt;p&gt;HTTP 헤더 중에는 ‘Vary’라는 항목이 있습니다.
동일한 URL에 대해 요청을 하더라도 요청한 사용자의 특징(User Agent, Accept Encoding, Origin 등등)에 따라 서로 다른 응답을 해 주기 위해서 존재하는 헤더입니다.
따라서 웹 캐시에서는 vary 헤더를 확인하고 해당 헤더에서 명시하는 조건에 따라 동일 URL이라 하더라도 다른 종류의 컨텐츠를 캐싱하고, 제공해야 합니다.&lt;/p&gt;

&lt;p&gt;기존 Wcache에서는 이런 vary object에 대한 고려가 충분하지 않았습니다. 아래 그림처럼 vary object 저장은 가능했지만,
리스트 형식으로 원하는 vary object가 나올 때까지 탐색해야 했고 그마저도 vary 헤더가 없는 normal object와 동시에 캐싱을 할 수 없는 이슈가 있었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/wcache-meta-before-after.png&quot; alt=&quot;Wcache의 기존 metadata 저장구조(a)와 개선된 저장구조(b)&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이를 해결하기 위해 저장 구조 설계 시 처음부터 vary object의 존재를 고려하였습니다. Metadata를 두 개의 타입 (Meta / Info)으로 나누어,
Meta에는 현재 Wcache에 캐싱되어있는 vary object의 종류와 info의 포인터를, Info에는 실제 컨텐츠의 정보 (offset, header 등)를 담도록 설계하였습니다.
이 구조를 통해 여러 개의 vary object가 있어도, normal object와 공존해도 문제없이 사용자가 원하는 컨텐츠를 제공할 수 있게 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;lock-구조-개선---동일-컨텐츠-접근-시-생기는-병목현상-제거&quot;&gt;Lock 구조 개선 - 동일 컨텐츠 접근 시 생기는 병목현상 제거&lt;/h2&gt;
&lt;p&gt;Wcache는 느슨한 구조의 actor model&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;을 가지고 있습니다. 사용자의 요청이 들어오면 다수의 actor(HTTP 요청 수신 / 응답 / 컨텐츠 처리 / 소스 서버 통신)를 돌아다니며 처리됩니다. 
각 actor는 I/O multiplexing 형식으로 동시에 여러 개의 요청을 다룰 수 있게 하여 최대한의 성능을 낼 수 있도록 설계되었습니다.
그러나 디스크 I/O를 하는 actor는 내부적으로 blocking read / write를 수행하게 되어 단일 thread로는 원활한 성능을 얻을 수 없기에 내부적으로 multi thread 모델을 채택하였습니다.&lt;/p&gt;

&lt;p&gt;그러다보니 해당 구조에서는 캐싱된 컨텐츠를 처리하는 actor에서 컨텐츠를 조회하고 검증하는 동안 불가피하게 캐시 key에 대해 광범위한 lock 처리를 해야 했습니다. 
이 lock은 컨텐츠가 새로 갱신되거나 삭제(Purge)될 때를 위해 필요하지만, 이전 구조에서는 read / write lock 구분이 없었습니다. 
이는 동일 컨텐츠를 집중적으로 요청할 때 해당 컨텐츠의 초당 처리수가 제한되는 문제를 야기합니다.
일반적으로 특정 이벤트&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;로 인해 트래픽이 증가하는 경우, 소수의 인기 있는 컨텐츠들이 집중적으로 요청되는 경우가 많으므로 이러한 성능 제한은 급작스런 트래픽 대응 시 잠재적인 문제가 될 수 있습니다.&lt;/p&gt;

&lt;p&gt;이를 해결하기 위해 먼저 read / write lock을 분리하여 평시에 컨텐츠가 집중적으로 요청되는 경우 동시에 접근이 가능할 수 있도록 하였습니다. 
더 나아가 lock의 범위를 줄이고 추후 유지보수를 쉽게 하기 위해 순수하게 디스크 I/O 부분과 캐시 컨텐츠를 검증하는 부분을 별도의 actor로 분리해 조금 더 효율적인 처리를 할 수 있도록 변경하였습니다.
이 조치는 동일 컨텐츠 요청에 대해 기존 대비 약 3배의 성능 향상을 이루어냅니다.&lt;/p&gt;

&lt;h1 id=&quot;결과&quot;&gt;결과&lt;/h1&gt;
&lt;p&gt;이번 개편은 개발부터 성능 안정화까지 약 1년에 걸쳐 진행되었습니다. 기존 Wcache 구조의 핵심 부분들을 전부 뜯어고치는 대 작업이었습니다.
이번 개편을 통해 더 안정적인 성능을 이끌어 낼 수 있었고, 기능적인 측면들 - vary object 저장 유연화, 컨텐츠 크기 제한 해제,
regular expression 기반 대량 캐시 퍼지 등 - 에서 큰 발전을 이룰 수 있게 되었습니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Bloom_filter&quot;&gt;Bloom Filter&lt;/a&gt;&amp;nbsp;&lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Actor_model&quot;&gt;Actor Model&lt;/a&gt;&amp;nbsp;&lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;다음 앱에서의 뉴스속보 및 날씨알림 등의 푸시, 카카오톡 채널탭 뱃지 등..&amp;nbsp;&lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 23 Oct 2017 12:00:00 +0900</pubDate>
        <link>http://localhost:8080/wcache-2/</link>
        <guid isPermaLink="true">http://localhost:8080/wcache-2/</guid>
        
        <category>web-cache</category>
        
        <category>storage</category>
        
        
      </item>
    
      <item>
        <title>분산 웹 캐시 (Wcache)의 개선과정 - Part 1</title>
        <description>&lt;h1 id=&quot;overview&quot;&gt;Overview&lt;/h1&gt;
&lt;p&gt;웹 서비스의 규모가 커지고 이용자의 수가 늘어날수록 서비스 제공자는 scalability 이슈에 직면합니다. 
그중에서도 실제 ‘로딩 속도’의 차이를 느끼게 해 주고 트래픽의 대부분을 차지하는 정적 컨텐츠의 신속한 제공은 서비스 품질을 좌우하는 중요한 요소가 되곤 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/static-contents.png&quot; alt=&quot;하나의 웹페이지에서도 수많은 컨텐츠가 불려진다&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이런 수많은 컨텐츠들(Javascript, css, image 등)을 빠르게 제공하기 위해 클라이언트와 서버 사이에 위치하며 컨텐츠를 임시로 저장하는 Middlebox를 웹 캐시(web cache)라고 합니다.
웹 캐시의 기능은 Apache Traffic Server, Nginx, Squid와 같은 어플리케이션에서 지원하고 있으며, 대량의 컨텐츠를 처리하기 위한 전용 하드웨어 형태의 상용 솔루션도 있습니다.&lt;/p&gt;

&lt;p&gt;본 포스트에서는 카카오에서 자체적으로 개발하여 운영 중인 웹 캐시, Wcache에 대한 간략한 소개를 진행하고 올해 상반기에 진행되었던 대대적인 구조 개편 내역을 다음 포스트에 설명하고자 합니다.&lt;/p&gt;

&lt;h1 id=&quot;part-1-분산-웹-캐시-wcache&quot;&gt;Part 1: 분산 웹 캐시, Wcache&lt;/h1&gt;

&lt;h2 id=&quot;개발-배경-및-기본적인-기능&quot;&gt;개발 배경 및 기본적인 기능&lt;/h2&gt;
&lt;p&gt;기존에 웹 캐시로 사용되던 상용 솔루션의 문제점은 아래와 같았습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;장비 대수가 증가함에 따라 늘어나는 라이센스 비용.&lt;/li&gt;
  &lt;li&gt;버그 수정 및 지원의 어려움.&lt;/li&gt;
  &lt;li&gt;기능 개선이 불가능하거나 / 느리다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이런 문제점은 점점 늘어나는 서비스들을 위한 기능을 추가하거나 장애 대응 및 트래픽 확장 시 걸림돌이 되었고, 자체적인 솔루션을 개발하는 계기가 되었습니다.
C 언어로 구현된 Wcache는 범용 하드웨어(x86)의 자원을 최대한 활용하면서도 안정적인 성능을 낼 수 있도록 하였으며(multi-thread, I/O multiplexing, Direct Memory Access), 
&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;HTTP 표준&lt;/a&gt;을 준수하는 캐시 정책, 컨텐츠 퍼지 및 
Reverse / Forward HTTP Proxy의 기본적인 기능(HTTP message control, access log, access control, DNS caching 등)을 지원합니다.&lt;/p&gt;

&lt;h2 id=&quot;저장-구조&quot;&gt;저장 구조&lt;/h2&gt;
&lt;p&gt;웹 캐시의 성능은 보통 저장장치의 I/O 속도에 의해 좌우됩니다.&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; 특히 일정 수준의 캐시 hit율을 보장하기 위해 수십~수백 GB의 캐시 용량이 필요한 경우에는
디스크에 얼마만큼 안정적이고 효율적으로 컨텐츠를 저장하고 읽어오는가에 따라 성능이 크게 차이 날 수 있습니다.&lt;/p&gt;

&lt;p&gt;컨텐츠 별로 파일을 만들어 저장하는 방식은 다수의 컨텐츠를 저장할 때 일반적인 범용 파일 시스템(ext3, ext4 등)상에서 많은 문제를 일으킵니다. 하나의 디렉토리에
많은 파일을 저장하기 힘들뿐더러, 다수의 디렉토리를 만들면 디스크 및 커널 메모리의 inode 캐시 낭비를 일으킵니다.
또한, 파일 개수가 많아질수록 접근 속도도 느려지고 용량 확보를 위해 오래된 컨텐츠를 삭제할 때에도 수많은 I/O가 발생하게 됩니다.
용량 활용 측면에서도 기본 파일 시스템 블럭 단위가 4KB이기 때문에 4KB 미만의 컨텐츠가 다수 존재할 경우 심한 용량 낭비를 유발합니다.&lt;/p&gt;

&lt;p&gt;이러한 문제 때문에 Wcache에서는 독자적인 저장 구조를 만들어 컨텐츠 저장에 활용하였습니다.
먼저 컨텐츠 데이터가 저장되는 디스크에는 미리 일정한 크기(디스크 크기에 따라 64MB ~ 10GB)의 BigFile들을 여러 개 생성해 두어 컨텐츠를 저장할 공간을 확보해 둡니다.
이는 디스크가 연속된 영역에 순차적으로 데이터를 쓸 수 있도록 해줍니다.
추가로, 디스크 쓰기 작업 횟수를 줄이기 위해 BigFile 내부를 ‘block’이라는 세부 구조로 나누어 캐시가 되는 컨텐츠를 바로 저장하지 않고
메모리에 적재 후 block 단위로만 디스크에 쓰는 방식을 취하여 성능 향상을 이끌었습니다.&lt;/p&gt;

&lt;p&gt;Metadata에는 URL을 기반으로 한 캐시 key와 컨텐츠가 저장되어 있는 위치(BigFile 정보 및 offset)등의 정보를 담고 있으며,
이 정보는 컨텐츠가 저장되는 BigFile과는 별개로 SQLite DB에 저장합니다.&lt;/p&gt;

&lt;p&gt;디스크와 메모리의 효율적인 사용을 위해 Wcache는 HTTP 헤더와 일부 metadata 정보를 메모리상에 구성해둔 LRU hash table에 캐싱합니다.
메모리에 캐싱되어 있는 컨텐츠에 대해서는 DB 접근 없이 바로 응답이 가능하며,
캐싱되어 있지 않은 컨텐츠에 접근할 때는 DB에서 컨텐츠가 저장되어 있는 BigFile 정보를 읽어 컨텐츠에 대한 정보를 읽어오게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/wcache-structure.png&quot; alt=&quot;In-memory hash table에 캐싱된 경우 컨텐츠를 접근하는 방법.&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;wcache의-분산-구성&quot;&gt;Wcache의 분산 구성&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/files/wcache-standalone.png&quot; alt=&quot;Standalone 상태의 Wcache를 병렬로 구성한 단순한 구조, 각 Wcache에 중복된 컨텐츠들이 캐싱되어있다.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;초기 Wcache는 위 그림처럼 load balancer (LB) 밑에 여러 개의 Wcache 노드를 병렬로 구성하였습니다. 트래픽 대응을 위해서는 괜찮은 구조였지만,
LB가 사용자 요청을 단순히 round robin 방식으로 분산하고 있어 모든 Wcache에 중복된 컨텐츠들이 캐싱되어 이 구조로는 높은 캐시 hit율을 얻기 힘들었습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/wcache-cluster.png&quot; alt=&quot;단순한 클러스터 구조. Load Balancer를 통해 분산된 클라이언트 요청을 해당 컨텐츠가 있는 Wcache로 라우팅 해준다.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이를 해결하기 위해 Wcache는 분산 구조를 지원하였습니다. 위 그림처럼 여러 대의 Wcache 노드로 구성된 클러스터를 구성하여 consistent hashing
기법을 이용해 컨텐츠를 고르게 분포시키고, 클라이언트 요청이 들어왔을 때 알맞은 노드에 요청을 라우팅 해주도록 설계하였습니다.
이 방법은 각 Wcache가 고유한 컨텐츠를 저장함으로써 캐시 효율을 증가시킬 수는 있었습니다. 그러나 특정 컨텐츠가 인기가 많은 hot item이 되는 경우,
(예: 위 그림의 Wcache-A에 존재하는 (a)컨텐츠) 수많은 요청이 하나의 Wcache로 몰리는 현상이 일어나게 되고, 결국 트래픽을 감당할 수 없게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/wcache-dual-layer.png&quot; alt=&quot;Dual layer 구조. 1차 layer는 아래의 Wcache들을 하나의 cluster로 바라본다. 2차 layer는 기존처럼 standalone으로 동작한다.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이러한 문제를 해결하기 위해, 저희는 해당 클러스터 구조를 조금 더 발전시키기로 하였습니다. 위 그림처럼 Wcache를 두 개의 layer로 나눈 후,
1차 layer에 해당하는 Wcache들이 자신만의 분산 클러스터를 2차 layer로 가지도록 구성을 합니다. 이렇게 구성하면 1차 layer에서는 트래픽을 받고,
캐시 miss가 발생했을 경우 2차 layer 중 적절한 Wcache 노드에 요청합니다.
위 구조의 효과를 배가시키기 위해 1차 layer에 I/O 속도가 빠른 SSD를 탑재한 장비를,
2차 layer에는 상대적으로 속도는 느리지만 큰 저장공간을 가진 HDD 장비를 탑재하여 빠른 응답속도와 높은 캐시 hit율, 두 마리 토끼를 전부 잡을 수 있었습니다.
특히 소수의 유명한 컨텐츠가 매우 많이 요청되고, 나머지 컨텐츠의 사용 빈도가 기하급수적으로 낮아지는 long tail&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; 분포를 나타내는 서비스에 대해 높은 캐시 효율과 성능을 보여 주었습니다.&lt;/p&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;
&lt;p&gt;이렇게 구성한 Wcache는 현재 카카오 서비스에서 수십만 TPS 상당의 트래픽을 95% 이상의 높은 캐시 hit율을 가지며 안정적으로 처리하고 있습니다.
다음 포스트에서는 Wcache에 잠재되어 있는 문제점이 무엇이 있었는지, 또 어떤 방법으로 해결하였는지에 대해 알아보도록 하겠습니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://www.usenix.org/legacy/event/usenix99/full_papers/maltzahn/maltzahn.pdf&quot;&gt;Reducing the Disk I/O of Web Proxy Server Caches&lt;/a&gt;&amp;nbsp;&lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Long_tail&quot;&gt;Long tail distribution&lt;/a&gt;&amp;nbsp;&lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 23 Oct 2017 12:00:00 +0900</pubDate>
        <link>http://localhost:8080/wcache-1/</link>
        <guid isPermaLink="true">http://localhost:8080/wcache-1/</guid>
        
        <category>web-cache</category>
        
        <category>storage</category>
        
        
      </item>
    
      <item>
        <title>카카오 신입 공채 1차 코딩 테스트 문제 해설</title>
        <description>&lt;p&gt;‘블라인드’ 전형으로 실시되어 시작부터 엄청난 화제를 몰고 온 카카오 개발 신입 공채. 그 첫 번째 관문인 1차 코딩 테스트가 지난 9월 16일(토) 오후 2시부터 7시까지 장장 5시간 동안 온라인으로 치러졌습니다. 지원자들의 개발 능력을 잘 검증하기 위해 출제 위원들이 한 땀 한 땀 독창적이고 다양한 문제들을 만들어 냈고 문제에 이상은 없는지, 테스트케이스는 정확한지 풀어보고 또 풀어보며 만반의 준비를 기했습니다.&lt;/p&gt;

&lt;p&gt;먼저, 가장 궁금해하실 1차 합격 기준부터 알려드립니다. 1차 합격 기준은 총 7 문제 중 &lt;strong&gt;4 문제&lt;/strong&gt; 이상을 풀이한 분들입니다. 참고로 각 문제는 배점이 동일하므로 어떤 문제를 풀었던지 간에 관계는 없습니다.&lt;/p&gt;

&lt;p&gt;문제는 쉬운 난이도에서 어려운 난이도 순으로 풀 수 있도록 차례대로 배치했는데요. 앞서 얘기했듯 모든 문제는 배점이 동일하며 부분 점수는 없습니다. 즉, 채점 테스트케이스를 하나만 틀려도 오답으로 처리가 됩니다. 하지만 입출력 예제에 대부분의 예외 사항을 포함했고 따라서 입출력 테스트를 정상적으로 통과했다면 채점도 무리 없이 통과할 수 있도록 구성했습니다. 아울러 이번 코딩 테스트는 대회가 아니라 채용을 위한 시험인 만큼 ACM-ICPC 같은 어려운 알고리즘 설계 능력을 겨루는 문제가 아닌 업무에서 있을만한 상황을 가정하여 독창적이고 다양한 분야의 문제를 출제했고, 난이도 또한 비교적 쉬운 수준으로 조정하였습니다. 일반적으로 자료구조, 알고리즘 등의 전산학 기초에 대해 충분히 학습하였다면 누구나 풀 수 있을만한 문제들로 구성했습니다.&lt;/p&gt;

&lt;h1 id=&quot;언어별-통계&quot;&gt;언어별 통계&lt;/h1&gt;

&lt;p&gt;참가 언어별로는 자바가 전체의 43%로 가장 많았습니다. 그다음이 C++ 36%, 파이썬 11%, 자바스크립트 8% 순이었는데요. 스위프트는 0.7%의 참가자만이 선택하여 아직 스위프트가 주류로 성장하기엔 좀 더 시간이 필요해 보였습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;참가 언어: 자바 &amp;gt; C++ &amp;gt; 파이썬 &amp;gt; 자바스크립트 &amp;gt; 스위프트&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;4문제 이상을 풀이한 합격자의 비율은 C++이 25%로 가장 높았습니다. 그다음으로 파이썬이 24%로 근소한 차이로 뒤를 쫓고 있고, 참가자가 매우 적었던 스위프트도 20%로 합격률은 비교적 높았습니다. 그러나, 참가자가 가장 많았던 자바는 11%의 합격률 밖에 보여주지 못했으며 아쉽게도 자바스크립트의 경우 합격률이 9%에 불과했습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;합격 비율: C++ &amp;gt; 파이썬 &amp;gt; 스위프트 &amp;gt; 자바 &amp;gt; 자바스크립트&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;풀이한 언어의 평균 코드 라인 수를 알아볼까요?&lt;br /&gt;
C++이 평균적으로 가장 긴 라인 수를 자랑했습니다. 4번과 6번 문제는 78라인이나 필요했네요. 그다음은 근소한 차이로 자바입니다. 크게 차이가 나진 않지만 C++에 비해 평균적으로 5 ~ 6라인 정도가 짧았습니다. 그런데 재밌게도 가장 긴 코드는 자바가 차지했네요. 6번 문제의 경우 자바는 무려 80라인을 기록했습니다!&lt;/p&gt;

&lt;p&gt;그다음은 자바스크립트입니다. 자바에 비해 10라인 이상이 짧습니다. 역시나 파이썬이 가장 짧은 라인 수를 기록했는데요. 1번 문제는 고작 22라인 밖에 필요하지 않았습니다. 게다가 가장 긴 코드가 필요했던 6번 문제도 48라인으로 자바의 60% 수준에 불과합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;코드 라인 수: C++ &amp;gt; 자바 &amp;gt; 자바스크립트 &amp;gt; 파이썬&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이외에도 여러 언어를 섞어서 풀이한 분들이 전체의 5%나 되었으며, ‘C++ + 자바 + 자바스크립트 + 파이썬’ 이 4가지 언어를 동시에 섞어서 풀이한 분도 계셨네요.&lt;/p&gt;

&lt;p&gt;긴 시간 동안 시험을 치르고, 문제를 풀이하느라 다들 고생 많이 하셨습니다.&lt;br /&gt;
자, 그렇다면 많은 분들이 궁금해하실 코딩 테스트 문제를 하나씩 짚어보도록 할까요?&lt;/p&gt;

&lt;h1 id=&quot;문제-설명&quot;&gt;문제 설명&lt;/h1&gt;

&lt;h2 id=&quot;1-비밀-지도난이도-하&quot;&gt;1. 비밀 지도(난이도: 하)&lt;/h2&gt;

&lt;p&gt;네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;지도는 한 변의 길이가 &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;인 정사각형 배열 형태로, 각 칸은 “공백”(“ “) 또는 “벽”(“#”) 두 종류로 이루어져 있다.&lt;/li&gt;
  &lt;li&gt;전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 “지도 1”과 “지도 2”라고 하자. 지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다.&lt;/li&gt;
  &lt;li&gt;“지도 1”과 “지도 2”는 각각 정수 배열로 암호화되어 있다.&lt;/li&gt;
  &lt;li&gt;암호화된 배열은 지도의 각 가로줄에서 벽 부분을 &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;, 공백 부분을 &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://t1.kakaocdn.net/welcome2018/secret8.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;네오가 프로도의 비상금을 손에 넣을 수 있도록, 비밀지도의 암호를 해독하는 작업을 도와줄 프로그램을 작성하라.&lt;/p&gt;

&lt;h3 id=&quot;입력-형식&quot;&gt;입력 형식&lt;/h3&gt;

&lt;p&gt;입력으로 지도의 한 변 크기 &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; 과 2개의 정수 배열 &lt;code class=&quot;highlighter-rouge&quot;&gt;arr1&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;arr2&lt;/code&gt;가 들어온다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1 ≦ &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; ≦ 16&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;arr1&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;arr2&lt;/code&gt;는 길이 &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;인 정수 배열로 주어진다.&lt;/li&gt;
  &lt;li&gt;정수 배열의 각 원소 &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;를 이진수로 변환했을 때의 길이는 &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; 이하이다. 즉, 0 ≦ &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; ≦ 2^n - 1을 만족한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;출력-형식&quot;&gt;출력 형식&lt;/h3&gt;

&lt;p&gt;원래의 비밀지도를 해독하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;#&quot;&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;공백&lt;/code&gt;으로 구성된 문자열 배열로 출력하라.&lt;/p&gt;

&lt;h3 id=&quot;입출력-예제&quot;&gt;입출력 예제&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;매개변수&lt;/th&gt;
      &lt;th&gt;값&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;n&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;arr1&lt;/td&gt;
      &lt;td&gt;[9, 20, 28, 18, 11]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;arr2&lt;/td&gt;
      &lt;td&gt;[30, 1, 21, 17, 28]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;출력&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[&quot;#####&quot;,&quot;# # #&quot;, &quot;### #&quot;, &quot;# ##&quot;, &quot;#####&quot;]&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;매개변수&lt;/th&gt;
      &lt;th&gt;값&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;n&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;arr1&lt;/td&gt;
      &lt;td&gt;[46, 33, 33 ,22, 31, 50]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;arr2&lt;/td&gt;
      &lt;td&gt;[27 ,56, 19, 14, 14, 10]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;출력&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[&quot;######&quot;, &quot;###  #&quot;, &quot;##  ##&quot;, &quot; #### &quot;, &quot; #####&quot;, &quot;### # &quot;]&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;문제-해설&quot;&gt;문제 해설&lt;/h3&gt;

&lt;p&gt;이 문제는 비트 연산&lt;sup&gt;Bitwise Operation&lt;/sup&gt;을 묻는 문제입니다. 이미 문제 예시에 2진수로 처리하는 힌트가 포함되어 있고, 둘 중 하나가 1일 경우에 벽 &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt;이 생기기  때문에 OR로 처리하면 간단히 풀 수 있습니다. 아주 쉬운 문제였던 만큼 &lt;code class=&quot;highlighter-rouge&quot;&gt;if else&lt;/code&gt;로 풀이한 분들도 많이 발견되었는데요. 정답으로는 간주되지만 이 문제는 비트 연산을 잘 다룰 수 있는지를 묻고자 하는 의도였던 만큼 앞으로 이런 유형의 문제를 풀 때는 비트 연산을 꼭 기억하시기 바랍니다.&lt;/p&gt;

&lt;p&gt;이 문제의 정답률은 81.78%입니다. 첫 번째 문제이고 가장 쉬운 문제였던 만큼 많은 분들이 잘 풀어주셨습니다.&lt;/p&gt;

&lt;h2 id=&quot;2-다트-게임난이도-하&quot;&gt;2. 다트 게임(난이도: 하)&lt;/h2&gt;

&lt;p&gt;카카오톡에 뜬 네 번째 별! 심심할 땐? 카카오톡 게임별~&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://t1.kakaocdn.net/welcome2018/gamestar.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;카카오톡 게임별의 하반기 신규 서비스로 다트 게임을 출시하기로 했다. 다트 게임은 다트판에 다트를 세 차례 던져 그 점수의 합계로 실력을 겨루는 게임으로, 모두가 간단히 즐길 수 있다.&lt;br /&gt;
갓 입사한 무지는 코딩 실력을 인정받아 게임의 핵심 부분인 점수 계산 로직을 맡게 되었다. 다트 게임의 점수 계산 로직은 아래와 같다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;다트 게임은 총 3번의 기회로 구성된다.&lt;/li&gt;
  &lt;li&gt;각 기회마다 얻을 수 있는 점수는 0점에서 10점까지이다.&lt;/li&gt;
  &lt;li&gt;점수와 함께 Single(&lt;code class=&quot;highlighter-rouge&quot;&gt;S&lt;/code&gt;), Double(&lt;code class=&quot;highlighter-rouge&quot;&gt;D&lt;/code&gt;), Triple(&lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;) 영역이 존재하고 각 영역 당첨 시 점수에서 1제곱, 2제곱, 3제곱 (점수^1 , 점수^2 , 점수^3 )으로 계산된다.&lt;/li&gt;
  &lt;li&gt;옵션으로 스타상(&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;) , 아차상(&lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt;)이 존재하며 스타상(&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;) 당첨 시 해당 점수와 바로 전에 얻은 점수를 각 2배로 만든다. 아차상(&lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt;) 당첨 시 해당 점수는 마이너스된다.&lt;/li&gt;
  &lt;li&gt;스타상(&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;)은 첫 번째 기회에서도 나올 수 있다. 이 경우 첫 번째 스타상(&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;)의 점수만 2배가 된다. (예제 4번 참고)&lt;/li&gt;
  &lt;li&gt;스타상(&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;)의 효과는 다른 스타상(&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;)의 효과와 중첩될 수 있다. 이 경우 중첩된 스타상(&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;) 점수는 4배가 된다. (예제 4번 참고)&lt;/li&gt;
  &lt;li&gt;스타상(&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;)의 효과는 아차상(&lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt;)의 효과와 중첩될 수 있다. 이 경우 중첩된 아차상(&lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt;)의 점수는 -2배가 된다. (예제 5번 참고)&lt;/li&gt;
  &lt;li&gt;Single(&lt;code class=&quot;highlighter-rouge&quot;&gt;S&lt;/code&gt;), Double(&lt;code class=&quot;highlighter-rouge&quot;&gt;D&lt;/code&gt;), Triple(&lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;)은 점수마다 하나씩 존재한다.&lt;/li&gt;
  &lt;li&gt;스타상(&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;), 아차상(&lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt;)은 점수마다 둘 중 하나만 존재할 수 있으며, 존재하지 않을 수도 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;0~10의 정수와 문자 &lt;code class=&quot;highlighter-rouge&quot;&gt;S, D, T, *, #&lt;/code&gt;로 구성된 문자열이 입력될 시 총점수를 반환하는 함수를 작성하라.&lt;/p&gt;

&lt;h3 id=&quot;입력-형식-1&quot;&gt;입력 형식&lt;/h3&gt;

&lt;p&gt;“점수|보너스|[옵션]”으로 이루어진 문자열 3세트.&lt;br /&gt;
예) &lt;code class=&quot;highlighter-rouge&quot;&gt;1S2D*3T&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;점수는 0에서 10 사이의 정수이다.&lt;/li&gt;
  &lt;li&gt;보너스는 S, D, T 중 하나이다.&lt;/li&gt;
  &lt;li&gt;옵선은 &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;이나 &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt; 중 하나이며, 없을 수도 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;출력-형식-1&quot;&gt;출력 형식&lt;/h3&gt;

&lt;p&gt;3번의 기회에서 얻은 점수 합계에 해당하는 정수값을 출력한다.&lt;br /&gt;
예) 37&lt;/p&gt;

&lt;h3 id=&quot;입출력-예제-1&quot;&gt;입출력 예제&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;예제&lt;/th&gt;
      &lt;th&gt;dartResult&lt;/th&gt;
      &lt;th&gt;answer&lt;/th&gt;
      &lt;th&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1S2D*3T&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;37&lt;/td&gt;
      &lt;td&gt;1^1 * 2 + 2^2 * 2 + 3^3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1D2S#10S&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;1^2 + 2^1 * (-1) + 10^1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1D2S0T&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;1^2 + 2^1 + 0^3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1S*2T*3S&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;23&lt;/td&gt;
      &lt;td&gt;1^1 * 2 * 2 + 2^3 * 2 + 3^1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1D#2S*3S&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;1^2 * (-1) * 2 + 2^1 * 2 + 3^1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1T2D3D#&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;-4&lt;/td&gt;
      &lt;td&gt;1^3 + 2^2 + 3^2 * (-1)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1D2S3T*&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;59&lt;/td&gt;
      &lt;td&gt;1^2 + 2^1 * 2 + 3^3 * 2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;문제-해설-1&quot;&gt;문제 해설&lt;/h3&gt;

&lt;p&gt;문자열 처리&lt;sup&gt;String Manipulation&lt;/sup&gt;를 묻는 문제입니다. 앞에서부터 한 글자씩 잘라서 처리할 수 있고, 또는 간단한 컴파일러를 만들듯이 토큰화&lt;sup&gt;Tokenizing&lt;/sup&gt;와 의미 분석&lt;sup&gt;Semantic Analysis&lt;/sup&gt;을 통해 어렵지 않게 계산할 수 있습니다.&lt;/p&gt;

&lt;p&gt;점수 중에는 한 자리뿐만 아니라 두 자리인 10점도 포함되어 있기 때문에 한 글자씩 잘라서 처리할때는 그 부분에 유의해야겠네요. 토큰화로 처리할 때는 정규식을 사용하면 비교적 쉽게 잘라낼 수 있습니다. S, D, T는 각각 원점수, 제곱, 세제곱으로 처리하고 스타상은 두 배로 계산하면 됩니다. 참, 아차상은 마이너스 점수라는 점에 유의하세요.&lt;/p&gt;

&lt;p&gt;이 문제의 정답률은 73.47%입니다. 앞서 비밀지도 보다는 낮지만 그래도 많은 분들이 잘 풀어주셨습니다.&lt;/p&gt;

&lt;h2 id=&quot;3-캐시난이도-하&quot;&gt;3. 캐시(난이도: 하)&lt;/h2&gt;

&lt;p&gt;지도개발팀에서 근무하는 제이지는 지도에서 도시 이름을 검색하면 해당 도시와 관련된 맛집 게시물들을 데이터베이스에서 읽어 보여주는 서비스를 개발하고 있다.&lt;br /&gt;
이 프로그램의 테스팅 업무를 담당하고 있는 어피치는 서비스를 오픈하기 전 각 로직에 대한 성능 측정을 수행하였는데, 제이지가 작성한 부분 중 데이터베이스에서 게시물을 가져오는 부분의 실행시간이 너무 오래 걸린다는 것을 알게 되었다.&lt;br /&gt;
어피치는 제이지에게 해당 로직을 개선하라고 닦달하기 시작하였고, 제이지는 DB 캐시를 적용하여 성능 개선을 시도하고 있지만 캐시 크기를 얼마로 해야 효율적인지 몰라 난감한 상황이다.&lt;/p&gt;

&lt;p&gt;어피치에게 시달리는 제이지를 도와, DB 캐시를 적용할 때 캐시 크기에 따른 실행시간 측정 프로그램을 작성하시오.&lt;/p&gt;

&lt;h3 id=&quot;입력-형식-2&quot;&gt;입력 형식&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;캐시 크기(&lt;code class=&quot;highlighter-rouge&quot;&gt;cacheSize&lt;/code&gt;)와 도시이름 배열(&lt;code class=&quot;highlighter-rouge&quot;&gt;cities&lt;/code&gt;)을 입력받는다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cacheSize&lt;/code&gt;는 정수이며, 범위는 0 ≦ &lt;code class=&quot;highlighter-rouge&quot;&gt;cacheSize&lt;/code&gt; ≦ 30 이다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cities&lt;/code&gt;는 도시 이름으로 이뤄진 문자열 배열로, 최대 도시 수는 100,000개이다.&lt;/li&gt;
  &lt;li&gt;각 도시 이름은 공백, 숫자, 특수문자 등이 없는 영문자로 구성되며, 대소문자 구분을 하지 않는다. 도시 이름은 최대 20자로 이루어져 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;출력-형식-2&quot;&gt;출력 형식&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;입력된 도시이름 배열을 순서대로 처리할 때, “총 실행시간”을 출력한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;조건&quot;&gt;조건&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;캐시 교체 알고리즘은 &lt;code class=&quot;highlighter-rouge&quot;&gt;LRU&lt;/code&gt;(Least Recently Used)를 사용한다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cache hit&lt;/code&gt;일 경우 실행시간은 &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;이다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cache miss&lt;/code&gt;일 경우 실행시간은 &lt;code class=&quot;highlighter-rouge&quot;&gt;5&lt;/code&gt;이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;입출력-예제-2&quot;&gt;입출력 예제&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;캐시크기(cacheSize)&lt;/th&gt;
      &lt;th&gt;도시이름(cities)&lt;/th&gt;
      &lt;th&gt;실행시간&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;[“Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”, “Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”]&lt;/td&gt;
      &lt;td&gt;50&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;[“Jeju”, “Pangyo”, “Seoul”, “Jeju”, “Pangyo”, “Seoul”, “Jeju”, “Pangyo”, “Seoul”]&lt;/td&gt;
      &lt;td&gt;21&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;[“Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”, “SanFrancisco”, “Seoul”, “Rome”, “Paris”, “Jeju”, “NewYork”, “Rome”]&lt;/td&gt;
      &lt;td&gt;60&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;[“Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”, “SanFrancisco”, “Seoul”, “Rome”, “Paris”, “Jeju”, “NewYork”, “Rome”]&lt;/td&gt;
      &lt;td&gt;52&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;[“Jeju”, “Pangyo”, “NewYork”, “newyork”]&lt;/td&gt;
      &lt;td&gt;16&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;[“Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”]&lt;/td&gt;
      &lt;td&gt;25&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;문제-해설-2&quot;&gt;문제 해설&lt;/h3&gt;

&lt;p&gt;여기서부터 문제가 좀 어려워졌던 거 같습니다. 정답률이 많이 낮은데요. 이 문제는 ‘조건’에도 나와있지만 LRU 캐시 교체 알고리즘을 구현하는 문제이고, 이미 잘 알고 있다면 또는 검색해봤다면 잘 구현된 LRU 알고리즘 코드는 많이 찾을 수 있습니다.&lt;/p&gt;

&lt;p&gt;단, 이 문제에는 입출력 예제에 캐시 사이즈 0이 포함되어 있습니다. 공개된 대부분의 LRU 구현 코드는 0일 때의 비정상적인 상황은 가정하지 않고 있기 때문에 생각 없이 그냥 가져와 붙인다면 에러가 나서 많이 고생했을 거 같네요. 하지만 사이즈 0을 처리하는 예외 처리 자체는 어렵지 않게 구현할 수 있으므로 입출력 예제가 왜 자꾸 틀리는지를 유심히 살펴봤다면 쉽게 풀 수 있는 문제입니다.&lt;/p&gt;

&lt;p&gt;아울러 검색해서 가져온 코드는 반드시 사용 가능한지 라이선스를 확인하고, 가져올 때는 꼭 출처를 명시해야 한다는 점 잊지 마세요.&lt;/p&gt;

&lt;p&gt;이 문제의 정답률은 45.26%입니다.&lt;/p&gt;

&lt;h2 id=&quot;4-셔틀버스난이도-중&quot;&gt;4. 셔틀버스(난이도: 중)&lt;/h2&gt;

&lt;p&gt;카카오에서는 무료 셔틀버스를 운행하기 때문에 판교역에서 편하게 사무실로 올 수 있다. 카카오의 직원은 서로를 ‘크루’라고 부르는데, 아침마다 많은 크루들이 이 셔틀을 이용하여 출근한다.&lt;/p&gt;

&lt;p&gt;이 문제에서는 편의를 위해 셔틀은 다음과 같은 규칙으로 운행한다고 가정하자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;셔틀은 &lt;code class=&quot;highlighter-rouge&quot;&gt;09:00&lt;/code&gt;부터 총 &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;회 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;분 간격으로 역에 도착하며, 하나의 셔틀에는 최대 &lt;code class=&quot;highlighter-rouge&quot;&gt;m&lt;/code&gt;명의 승객이 탈 수 있다.&lt;/li&gt;
  &lt;li&gt;셔틀은 도착했을 때 도착한 순간에 대기열에 선 크루까지 포함해서 대기 순서대로 태우고 바로 출발한다. 예를 들어 &lt;code class=&quot;highlighter-rouge&quot;&gt;09:00&lt;/code&gt;에 도착한 셔틀은 자리가 있다면 &lt;code class=&quot;highlighter-rouge&quot;&gt;09:00&lt;/code&gt;에 줄을 선 크루도 탈 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;일찍 나와서 셔틀을 기다리는 것이 귀찮았던 콘은, 일주일간의 집요한 관찰 끝에 어떤 크루가 몇 시에 셔틀 대기열에 도착하는지 알아냈다. 콘이 셔틀을 타고 사무실로 갈 수 있는 도착 시각 중 제일 늦은 시각을 구하여라.&lt;/p&gt;

&lt;p&gt;단, 콘은 게으르기 때문에 같은 시각에 도착한 크루 중 대기열에서 제일 뒤에 선다. 또한, 모든 크루는 잠을 자야 하므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;23:59&lt;/code&gt;에 집에 돌아간다. 따라서 어떤 크루도 다음날 셔틀을 타는 일은 없다.&lt;/p&gt;

&lt;h3 id=&quot;입력-형식-3&quot;&gt;입력 형식&lt;/h3&gt;

&lt;p&gt;셔틀 운행 횟수 &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;, 셔틀 운행 간격 &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;, 한 셔틀에 탈 수 있는 최대 크루 수 &lt;code class=&quot;highlighter-rouge&quot;&gt;m&lt;/code&gt;, 크루가 대기열에 도착하는 시각을 모은 배열 &lt;code class=&quot;highlighter-rouge&quot;&gt;timetable&lt;/code&gt;이 입력으로 주어진다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;0 ＜ &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; ≦ 10&lt;/li&gt;
  &lt;li&gt;0 ＜ &lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt; ≦ 60&lt;/li&gt;
  &lt;li&gt;0 ＜ &lt;code class=&quot;highlighter-rouge&quot;&gt;m&lt;/code&gt; ≦ 45&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;timetable&lt;/code&gt;은 최소 길이 1이고 최대 길이 2000인 배열로, 하루 동안 크루가 대기열에 도착하는 시각이 &lt;code class=&quot;highlighter-rouge&quot;&gt;HH:MM&lt;/code&gt; 형식으로 이루어져 있다.&lt;/li&gt;
  &lt;li&gt;크루의 도착 시각 &lt;code class=&quot;highlighter-rouge&quot;&gt;HH:MM&lt;/code&gt;은 &lt;code class=&quot;highlighter-rouge&quot;&gt;00:01&lt;/code&gt;에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;23:59&lt;/code&gt; 사이이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;출력-형식-3&quot;&gt;출력 형식&lt;/h3&gt;

&lt;p&gt;콘이 무사히 셔틀을 타고 사무실로 갈 수 있는 제일 늦은 도착 시각을 출력한다. 도착 시각은 &lt;code class=&quot;highlighter-rouge&quot;&gt;HH:MM&lt;/code&gt; 형식이며, &lt;code class=&quot;highlighter-rouge&quot;&gt;00:00&lt;/code&gt;에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;23:59&lt;/code&gt; 사이의 값이 될 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;입출력-예제-3&quot;&gt;입출력 예제&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;n&lt;/th&gt;
      &lt;th&gt;t&lt;/th&gt;
      &lt;th&gt;m&lt;/th&gt;
      &lt;th&gt;timetable&lt;/th&gt;
      &lt;th&gt;answer&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;[“08:00”, “08:01”, “08:02”, “08:03”]&lt;/td&gt;
      &lt;td&gt;“09:00”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;[“09:10”, “09:09”, “08:00”]&lt;/td&gt;
      &lt;td&gt;“09:09”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;[“09:00”, “09:00”, “09:00”, “09:00”]&lt;/td&gt;
      &lt;td&gt;“08:59”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;[“00:01”, “00:01”, “00:01”, “00:01”, “00:01”]&lt;/td&gt;
      &lt;td&gt;“00:00”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;[“23:59”]&lt;/td&gt;
      &lt;td&gt;“09:00”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;60&lt;/td&gt;
      &lt;td&gt;45&lt;/td&gt;
      &lt;td&gt;[“23:59”,”23:59”, “23:59”, “23:59”, “23:59”, “23:59”, “23:59”, “23:59”, “23:59”, “23:59”, “23:59”, “23:59”, “23:59”, “23:59”, “23:59”, “23:59”]&lt;/td&gt;
      &lt;td&gt;“18:00”&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;문제-해설-3&quot;&gt;문제 해설&lt;/h3&gt;

&lt;p&gt;쉬워 보이는데 어려운 문제가 바로 이 문제였던 거 같네요. 당초 난이도를 ‘중’으로 두고 문제를 중간 즈음에 배치하였는데, 시간을 계산하는 부분에서 많은 분들이 어려워하셨던 거 같습니다.&lt;/p&gt;

&lt;p&gt;예를 들어 2번 입출력 예제의 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;[&quot;09:10&quot;, &quot;09:09&quot;, &quot;08:00&quot;]&lt;/code&gt;인데 이 경우 두 번째 버스는 9:10분에 출발하기 때문에 9:10분에 오면 되지 않느냐 많이들 혼동하셨을 거 같아요. 하지만 9:00에 오는 버스는 8:00에 대기하는 크루 1명만 탑승할 수 있고, 따라서 9:10 버스에는 남아 있는 두 명이 모두 타게 됩니다. 따라서 좀 더 이른 9:09에 와야 탑승할 수 있습니다.&lt;/p&gt;

&lt;p&gt;전체 계산은 어렵지 않지만 이처럼 정확하게 시간 계산을 해야 하는 부분이 많고 마지막 버스 시간까지 빈틈없이 계산해야 해서 많은 분들이 실수를 한 거 같습니다. 이 문제는 정답률이 두 번째로 낮은 26.79%입니다.&lt;/p&gt;

&lt;h2 id=&quot;5-뉴스-클러스터링난이도-중&quot;&gt;5. 뉴스 클러스터링(난이도: 중)&lt;/h2&gt;

&lt;p&gt;여러 언론사에서 쏟아지는 뉴스, 특히 속보성 뉴스를 보면 비슷비슷한 제목의 기사가 많아 정작 필요한 기사를 찾기가 어렵다. Daum 뉴스의 개발 업무를 맡게 된 신입사원 튜브는 사용자들이 편리하게 다양한 뉴스를 찾아볼 수 있도록 문제점을 개선하는 업무를 맡게 되었다.&lt;/p&gt;

&lt;p&gt;개발의 방향을 잡기 위해 튜브는 우선 최근 화제가 되고 있는 “카카오 신입 개발자 공채” 관련 기사를 검색해보았다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;카카오 첫 공채..’블라인드’ 방식 채용&lt;/li&gt;
  &lt;li&gt;카카오, 합병 후 첫 공채.. 블라인드 전형으로 개발자 채용&lt;/li&gt;
  &lt;li&gt;카카오, 블라인드 전형으로 신입 개발자 공채&lt;/li&gt;
  &lt;li&gt;카카오 공채, 신입 개발자 코딩 능력만 본다&lt;/li&gt;
  &lt;li&gt;카카오, 신입 공채.. “코딩 실력만 본다”&lt;/li&gt;
  &lt;li&gt;카카오 “코딩 능력만으로 2018 신입 개발자 뽑는다”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;기사의 제목을 기준으로 “블라인드 전형”에 주목하는 기사와 “코딩 테스트”에 주목하는 기사로 나뉘는 걸 발견했다. 튜브는 이들을 각각 묶어서 보여주면 카카오 공채 관련 기사를 찾아보는 사용자에게 유용할 듯싶었다.&lt;/p&gt;

&lt;p&gt;유사한 기사를 묶는 기준을 정하기 위해서 논문과 자료를 조사하던 튜브는 “자카드 유사도”라는 방법을 찾아냈다.&lt;/p&gt;

&lt;p&gt;자카드 유사도는 집합 간의 유사도를 검사하는 여러 방법 중의 하나로 알려져 있다. 두 집합 &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt; 사이의 자카드 유사도 &lt;code class=&quot;highlighter-rouge&quot;&gt;J(A, B)&lt;/code&gt;는 두 집합의 교집합 크기를 두 집합의 합집합 크기로 나눈 값으로 정의된다.&lt;/p&gt;

&lt;p&gt;예를 들어 집합 &lt;code class=&quot;highlighter-rouge&quot;&gt;A = {1, 2, 3}&lt;/code&gt;, 집합 &lt;code class=&quot;highlighter-rouge&quot;&gt;B = {2, 3, 4}&lt;/code&gt;라고 할 때, 교집합 &lt;code class=&quot;highlighter-rouge&quot;&gt;A ∩ B = {2, 3}&lt;/code&gt;, 합집합 &lt;code class=&quot;highlighter-rouge&quot;&gt;A ∪ B = {1, 2, 3, 4}&lt;/code&gt;이 되므로, 집합 A, B 사이의 자카드 유사도 &lt;code class=&quot;highlighter-rouge&quot;&gt;J(A, B) = 2/4 = 0.5&lt;/code&gt;가 된다. 집합 A와 집합 B가 모두 공집합일 경우에는 나눗셈이 정의되지 않으니 따로 &lt;code class=&quot;highlighter-rouge&quot;&gt;J(A, B) = 1&lt;/code&gt;로 정의한다.&lt;/p&gt;

&lt;p&gt;자카드 유사도는 원소의 중복을 허용하는 다중집합에 대해서 확장할 수 있다. 다중집합 A는 원소 “1”을 3개 가지고 있고, 다중집합 B는 원소 “1”을 5개 가지고 있다고 하자. 이 다중집합의 교집합 &lt;code class=&quot;highlighter-rouge&quot;&gt;A ∩ B&lt;/code&gt;는 원소 “1”을 min(3, 5)인 3개, 합집합 &lt;code class=&quot;highlighter-rouge&quot;&gt;A ∪ B&lt;/code&gt;는 원소 “1”을 max(3, 5)인 5개 가지게 된다. 다중집합 &lt;code class=&quot;highlighter-rouge&quot;&gt;A = {1, 1, 2, 2, 3}&lt;/code&gt;, 다중집합 &lt;code class=&quot;highlighter-rouge&quot;&gt;B = {1, 2, 2, 4, 5}&lt;/code&gt;라고 하면, 교집합 &lt;code class=&quot;highlighter-rouge&quot;&gt;A ∩ B = {1, 2, 2}&lt;/code&gt;, 합집합 &lt;code class=&quot;highlighter-rouge&quot;&gt;A ∪ B = {1, 1, 2, 2, 3, 4, 5}&lt;/code&gt;가 되므로, 자카드 유사도 &lt;code class=&quot;highlighter-rouge&quot;&gt;J(A, B) = 3/7&lt;/code&gt;, 약 &lt;code class=&quot;highlighter-rouge&quot;&gt;0.42&lt;/code&gt;가 된다.&lt;/p&gt;

&lt;p&gt;이를 이용하여 문자열 사이의 유사도를 계산하는데 이용할 수 있다. 문자열 “FRANCE”와 “FRENCH”가 주어졌을 때, 이를 두 글자씩 끊어서 다중집합을 만들 수 있다. 각각 {FR, RA, AN, NC, CE}, {FR, RE, EN, NC, CH}가 되며, 교집합은 {FR, NC}, 합집합은 {FR, RA, AN, NC, CE, RE, EN, CH}가 되므로, 두 문자열 사이의 자카드 유사도 &lt;code class=&quot;highlighter-rouge&quot;&gt;J(&quot;FRANCE&quot;, &quot;FRENCH&quot;) = 2/8 = 0.25&lt;/code&gt;가 된다.&lt;/p&gt;

&lt;h3 id=&quot;입력-형식-4&quot;&gt;입력 형식&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;입력으로는 &lt;code class=&quot;highlighter-rouge&quot;&gt;str1&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;str2&lt;/code&gt;의 두 문자열이 들어온다. 각 문자열의 길이는 2 이상, 1,000 이하이다.&lt;/li&gt;
  &lt;li&gt;입력으로 들어온 문자열은 두 글자씩 끊어서 다중집합의 원소로 만든다. 이때 영문자로 된 글자 쌍만 유효하고, 기타 공백이나 숫자, 특수 문자가 들어있는 경우는 그 글자 쌍을 버린다. 예를 들어 “ab+”가 입력으로 들어오면, “ab”만 다중집합의 원소로 삼고, “b+”는 버린다.&lt;/li&gt;
  &lt;li&gt;다중집합 원소 사이를 비교할 때, 대문자와 소문자의 차이는 무시한다. “AB”와 “Ab”, “ab”는 같은 원소로 취급한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;출력-형식-4&quot;&gt;출력 형식&lt;/h3&gt;

&lt;p&gt;입력으로 들어온 두 문자열의 자카드 유사도를 출력한다. 유사도 값은 0에서 1 사이의 실수이므로, 이를 다루기 쉽도록 65536을 곱한 후에 소수점 아래를 버리고 정수부만 출력한다.&lt;/p&gt;

&lt;h3 id=&quot;예제-입출력&quot;&gt;예제 입출력&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;str1&lt;/th&gt;
      &lt;th&gt;str2&lt;/th&gt;
      &lt;th&gt;answer&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;FRANCE&lt;/td&gt;
      &lt;td&gt;french&lt;/td&gt;
      &lt;td&gt;16384&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;handshake&lt;/td&gt;
      &lt;td&gt;shake hands&lt;/td&gt;
      &lt;td&gt;65536&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;aa1+aa2&lt;/td&gt;
      &lt;td&gt;AAAA12&lt;/td&gt;
      &lt;td&gt;43690&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;E=M*C^2&lt;/td&gt;
      &lt;td&gt;e=m*c^2&lt;/td&gt;
      &lt;td&gt;65536&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;문제-해설-4&quot;&gt;문제 해설&lt;/h3&gt;

&lt;p&gt;이 문제는 자카드 유사도를 설명해주고 자카드 유사도를 직접 계산하는 프로그램을 작성하는 문제입니다. 자카드 유사도는 실무에서도 유사한 문서를 판별할 때 주로 쓰이는데요, 몰랐더라도 문제에서 자세히 설명해주기 때문에 이해하는데 어려움은 없었을 거 같습니다. 공식은 매우 간단한데요, 교집합을 합집합으로 나눈 수입니다. 다만, 이 값은 0에서 1 사이의 실수가 되는데, 여기서는 이를 다루기 쉽도록 65536을 곱한 후 소수점 아래를 버리고 정수부만 취하도록 합니다.&lt;/p&gt;

&lt;p&gt;문제 설명은 원소의 중복을 허용하는 다중집합&lt;sup&gt;multiset&lt;/sup&gt;으로 되어 있는데, 자주 접하는 자료구조가 아니고, 일부 언어에서는 기본으로 제공하는 자료구조가 아니라 어려워하는 분들이 있었습니다. 하지만 다중집합 자료구조를 쓰지 않더라도, 각 원소를 정렬된 배열에 넣은 후 병합 정렬&lt;sup&gt;Merge sort&lt;/sup&gt;에서 배웠던 코드를 응용, 어렵지 않게 합집합과 교집합 함수를 직접 구현할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;다중집합의 교집합, 합집합만 잘 구해낸다면 이 문제는 어렵지 않게 풀 수 있으며, 다만 집합 A와 B가 모두 공집합일 경우에는 나눗셈이 정의되지 않으므로&lt;sup&gt;division by zero&lt;/sup&gt; 따로 &lt;code class=&quot;highlighter-rouge&quot;&gt;J(A,B) = 1&lt;/code&gt;로 정의합니다. 즉, 65536을 곱하면 이 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;1 * 65536 = 65536&lt;/code&gt;이 정답이 됩니다. 예제 입출력에도 합집합이 공집합인 경우가 포함되어 있으므로 이 경우만 주의한다면 쉽게 풀 수 있는 문제입니다.&lt;/p&gt;

&lt;p&gt;이 문제의 정답률은 41.84%입니다.&lt;/p&gt;

&lt;h2 id=&quot;6-프렌즈4블록난이도-상&quot;&gt;6. 프렌즈4블록(난이도: 상)&lt;/h2&gt;

&lt;p&gt;블라인드 공채를 통과한 신입 사원 라이언은 신규 게임 개발 업무를 맡게 되었다. 이번에 출시할 게임 제목은 “프렌즈4블록”.&lt;br /&gt;
같은 모양의 카카오프렌즈 블록이 2×2 형태로 4개가 붙어있을 경우 사라지면서 점수를 얻는 게임이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://t1.kakaocdn.net/welcome2018/pang1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약 판이 위와 같이 주어질 경우, 라이언이 2×2로 배치된 7개 블록과 콘이 2×2로 배치된 4개 블록이 지워진다. 같은 블록은 여러 2×2에 포함될 수 있으며, 지워지는 조건에 만족하는 2×2 모양이 여러 개 있다면 한꺼번에 지워진다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://t1.kakaocdn.net/welcome2018/pang2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;블록이 지워진 후에 위에 있는 블록이 아래로 떨어져 빈 공간을 채우게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://t1.kakaocdn.net/welcome2018/pang3.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만약 빈 공간을 채운 후에 다시 2×2 형태로 같은 모양의 블록이 모이면 다시 지워지고 떨어지고를 반복하게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://t1.kakaocdn.net/welcome2018/pang4.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 초기 배치를 문자로 표시하면 아래와 같다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;TTTANT
RRFACC
RRRFCC
TRRRAA
TTMMMF
TMMTTJ
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;각 문자는 라이언(R), 무지(M), 어피치(A), 프로도(F), 네오(N), 튜브(T), 제이지(J), 콘(C)을 의미한다&lt;/p&gt;

&lt;p&gt;입력으로 블록의 첫 배치가 주어졌을 때, 지워지는 블록은 모두 몇 개인지 판단하는 프로그램을 제작하라.&lt;/p&gt;

&lt;h3 id=&quot;입력-형식-5&quot;&gt;입력 형식&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;입력으로 판의 높이 &lt;code class=&quot;highlighter-rouge&quot;&gt;m&lt;/code&gt;, 폭 &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;과 판의 배치 정보 &lt;code class=&quot;highlighter-rouge&quot;&gt;board&lt;/code&gt;가 들어온다.&lt;/li&gt;
  &lt;li&gt;2 ≦ &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;m&lt;/code&gt; ≦ 30&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;board&lt;/code&gt;는 길이 &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt;인 문자열 &lt;code class=&quot;highlighter-rouge&quot;&gt;m&lt;/code&gt;개의 배열로 주어진다. 블록을 나타내는 문자는 대문자 A에서 Z가 사용된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;출력-형식-5&quot;&gt;출력 형식&lt;/h3&gt;

&lt;p&gt;입력으로 주어진 판 정보를 가지고 몇 개의 블록이 지워질지 출력하라.&lt;/p&gt;

&lt;h3 id=&quot;입출력-예제-4&quot;&gt;입출력 예제&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;m&lt;/th&gt;
      &lt;th&gt;n&lt;/th&gt;
      &lt;th&gt;board&lt;/th&gt;
      &lt;th&gt;answer&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;[“CCBDE”, “AAADE”, “AAABF”, “CCBBF”]&lt;/td&gt;
      &lt;td&gt;14&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;[“TTTANT”, “RRFACC”, “RRRFCC”, “TRRRAA”, “TTMMMF”, “TMMTTJ”]&lt;/td&gt;
      &lt;td&gt;15&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;예제에-대한-설명&quot;&gt;예제에 대한 설명&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;입출력 예제 1의 경우, 첫 번째에는 A 블록 6개가 지워지고, 두 번째에는 B 블록 4개와 C 블록 4개가 지워져, 모두 14개의 블록이 지워진다.&lt;/li&gt;
  &lt;li&gt;입출력 예제 2는 본문 설명에 있는 그림을 옮긴 것이다. 11개와 4개의 블록이 차례로 지워지며, 모두 15개의 블록이 지워진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;문제-해설-5&quot;&gt;문제 해설&lt;/h3&gt;

&lt;p&gt;게임 요구 사항을 구현해보는 문제입니다. 같은 모양의 카카오프렌즈 블록이 2x2 형태로 4개가 붙어있을 경우 사라지면서 점수를 얻는 게임인데요. 인접한 모든 블록이 사라지는 실제 게임들과 달리 계산을 쉽게 하기 위해 2x2로 제한하고, 사라진 블록 자리에는 새로운 블록이 채워지지 않습니다. 그럼에도 불구하고 인접한 블록을 모두 스캔해야 하는 문제라 짧지 않은 코드가 필요했을 것 같네요. 이번 시험에서 가장 긴 코드가 필요한 문제였습니다. 자바의 경우 무려 80라인이나 필요했네요. 블록 매트릭스를 생성하여 스캔하고 제거해 나가는 작업을 반복하면서 더 이상 제거되지 않을 때 사라진 블록 자리의 수를 계산하면 됩니다.&lt;/p&gt;

&lt;p&gt;이 문제의 정답률은 48.01%입니다.&lt;/p&gt;

&lt;h2 id=&quot;7-추석-트래픽난이도-상&quot;&gt;7. 추석 트래픽(난이도: 상)&lt;/h2&gt;

&lt;p&gt;이번 추석에도 시스템 장애가 없는 명절을 보내고 싶은 어피치는 서버를 증설해야 할지 고민이다. 장애 대비용 서버 증설 여부를 결정하기 위해 작년 추석 기간인 9월 15일 로그 데이터를 분석한 후 초당 최대 처리량을 계산해보기로 했다. 초당 최대 처리량은 요청의 응답 완료 여부에 관계없이 임의 시간부터 1초(=1,000밀리초)간 처리하는 요청의 최대 개수를 의미한다.&lt;/p&gt;

&lt;h3 id=&quot;입력-형식-6&quot;&gt;입력 형식&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;solution&lt;/code&gt; 함수에 전달되는 &lt;code class=&quot;highlighter-rouge&quot;&gt;lines&lt;/code&gt; 배열은 N(1 ≦ N ≦ 2,000)개의 로그 문자열로 되어 있으며, 각 로그 문자열마다 요청에 대한 응답완료시간 S와 처리시간 T가 공백으로 구분되어 있다.&lt;/li&gt;
  &lt;li&gt;응답완료시간 S는 작년 추석인 2016년 9월 15일만 포함하여 고정 길이 &lt;code class=&quot;highlighter-rouge&quot;&gt;2016-09-15 hh:mm:ss.sss&lt;/code&gt; 형식으로 되어 있다.&lt;/li&gt;
  &lt;li&gt;처리시간 T는 &lt;code class=&quot;highlighter-rouge&quot;&gt;0.1s&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;0.312s&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;2s&lt;/code&gt; 와 같이 최대 소수점 셋째 자리까지 기록하며 뒤에는 초 단위를 의미하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;s&lt;/code&gt;로 끝난다.&lt;/li&gt;
  &lt;li&gt;예를 들어, 로그 문자열 &lt;code class=&quot;highlighter-rouge&quot;&gt;2016-09-15 03:10:33.020 0.011s&lt;/code&gt;은 “2016년 9월 15일 오전 3시 10분 33.010초”부터 “2016년 9월 15일 오전 3시 10분 33.020초”까지 “0.011초” 동안 처리된 요청을 의미한다. (처리시간은 시작시간과 끝시간을 포함)&lt;/li&gt;
  &lt;li&gt;서버에는 타임아웃이 3초로 적용되어 있기 때문에 처리시간은 0.001 ≦ T ≦ 3.000이다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;lines&lt;/code&gt; 배열은 응답완료시간 S를 기준으로 오름차순 정렬되어 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;출력-형식-6&quot;&gt;출력 형식&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;solution&lt;/code&gt; 함수에서는 로그 데이터 &lt;code class=&quot;highlighter-rouge&quot;&gt;lines&lt;/code&gt; 배열에 대해 초당 최대 처리량을 리턴한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;입출력-예제-5&quot;&gt;입출력 예제&lt;/h3&gt;

&lt;h4 id=&quot;예제-1&quot;&gt;예제 1&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;입력: [
“2016-09-15 01:00:04.001 2.0s”,
“2016-09-15 01:00:07.000 2s”
]&lt;/li&gt;
  &lt;li&gt;출력: 1&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;예제-2&quot;&gt;예제 2&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;입력: [
“2016-09-15 01:00:04.002 2.0s”,
“2016-09-15 01:00:07.000 2s”
]&lt;/li&gt;
  &lt;li&gt;출력: 2&lt;/li&gt;
  &lt;li&gt;설명: 처리시간은 시작시간과 끝시간을 포함하므로 
첫 번째 로그는 &lt;code class=&quot;highlighter-rouge&quot;&gt;01:00:02.003 ~ 01:00:04.002&lt;/code&gt;에서 2초 동안 처리되었으며,
두 번째 로그는 &lt;code class=&quot;highlighter-rouge&quot;&gt;01:00:05.001 ~ 01:00:07.000&lt;/code&gt;에서 2초 동안 처리된다.
따라서, 첫 번째 로그가 끝나는 시점과 두 번째 로그가 시작하는 시점의 구간인 &lt;code class=&quot;highlighter-rouge&quot;&gt;01:00:04.002 ~ 01:00:05.001&lt;/code&gt; 1초 동안 최대 2개가 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;예제-3&quot;&gt;예제 3&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;입력: [
“2016-09-15 20:59:57.421 0.351s”,
“2016-09-15 20:59:58.233 1.181s”,
“2016-09-15 20:59:58.299 0.8s”,
“2016-09-15 20:59:58.688 1.041s”,
“2016-09-15 20:59:59.591 1.412s”,
“2016-09-15 21:00:00.464 1.466s”,
“2016-09-15 21:00:00.741 1.581s”,
“2016-09-15 21:00:00.748 2.31s”,
“2016-09-15 21:00:00.966 0.381s”,
“2016-09-15 21:00:02.066 2.62s”
]&lt;/li&gt;
  &lt;li&gt;출력: 7&lt;/li&gt;
  &lt;li&gt;설명: 아래 타임라인 그림에서 빨간색으로 표시된 1초 각 구간의 처리량을 구해보면 &lt;code class=&quot;highlighter-rouge&quot;&gt;(1)&lt;/code&gt;은 4개, &lt;code class=&quot;highlighter-rouge&quot;&gt;(2)&lt;/code&gt;는 7개, &lt;code class=&quot;highlighter-rouge&quot;&gt;(3)&lt;/code&gt;는 2개임을 알 수 있다. 따라서 초당 최대 처리량은 7이 되며, 동일한 최대 처리량을 갖는 1초 구간은 여러 개 존재할 수 있으므로 이 문제에서는 구간이 아닌 개수만 출력한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://t1.kakaocdn.net/welcome2018/chuseok-01-v5.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;문제-해설-6&quot;&gt;문제 해설&lt;/h3&gt;

&lt;p&gt;이번 테스트의 마지막 문제이고, 가장 어려운 문제입니다. 초당 최대 처리량이 되는 구간 윈도우를 찾아야 하는 문제인데요. 당연히 처음부터 끝까지 스캔하기에는 범위가 너무 크고, 게다가 ms 단위로 되어 있기 때문에 첫 로그 시각부터 마지막 로그 시각까지 1ms씩 증가시키면서 1000ms 단위의 슬라이딩 윈도우로 풀면 &lt;code class=&quot;highlighter-rouge&quot;&gt;24 * 3600 * 1000 * n * 1000ms&lt;/code&gt; 만큼의 연산이 필요하기 때문에 이렇게는 풀 수가 없습니다.&lt;/p&gt;

&lt;p&gt;그렇다고 각 로그의 시작 시각부터 마지막 시각까지 1ms 씩 움직이면 &lt;code class=&quot;highlighter-rouge&quot;&gt;time(ms) * n^2&lt;/code&gt; 이 되며, time(ms)의 값은 대부분 천 단위 이상이기 때문에 마찬가지로 타임아웃이 발생하여 풀 수가 없습니다. 그런데 자세히 살펴보면 요청량이 변하는 순간은 각 로그의 시작과 끝뿐임을 알 수 있습니다. 따라서, 각 로그 별 2번의 비교 연산만 수행하면 되며 &lt;code class=&quot;highlighter-rouge&quot;&gt;2 * n^2&lt;/code&gt;, 빅오로 정리하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;O(n^2)&lt;/code&gt;에 풀 수가 있습니다. 빅오에서 제거된 상수항도 매우 작기 때문에 이 경우 무리 없이 문제를 풀 수 있게 되며 C++ 기준으로 10ms를 넘지 않습니다.&lt;/p&gt;

&lt;p&gt;물론, 이 문제는 윈도우를 사용하지 않고도 풀 수 있는 방법이 있습니다. 효율적인 알고리즘을 쓴다면, &lt;code class=&quot;highlighter-rouge&quot;&gt;O(n log n)&lt;/code&gt;으로 풀 수 있는 방법도 있으니 한 번 고민해보세요. 이 문제는 가장 어려운 문제였던 만큼 정답률은 가장 낮은 17.99%입니다.&lt;/p&gt;

&lt;h1 id=&quot;마무리하며&quot;&gt;마무리하며&lt;/h1&gt;

&lt;p&gt;이렇게 모든 문제를 돌아보고 간략한 해설을 곁들여 봤습니다. 어떠신가요?&lt;/p&gt;

&lt;p&gt;참여하신 분들 중 미처 풀지 못한 문제가 있었다면 문제 해설을 보면서 ‘조금만 더 시간이 있었더라면…‘라며 안타까움을 느끼는 분들이 많으실 거라 생각합니다. 여타의 코딩 대회와 달리 채용을 위한 시험인 만큼 재밌게 즐기기는 힘들었을 것입니다. 하지만, “천재는 노력하는 사람을 이길 수 없고, 노력하는 사람은 즐기는 사람을 이길 수 없다.”는 말이 있듯이, 끝까지 즐기는 마음 잊지 않고 코딩을 즐긴다면 언젠가 좋은 결과 있으리라 확신합니다. 마지막까지 잘 마무리하여 꼭 카카오에서 여러분들을 만나 뵙게 되길 기대하겠습니다.&lt;/p&gt;

&lt;p&gt;그럼, 2차 시험에서 다시 만나도록 할게요. 마지막까지 파이팅!&lt;/p&gt;
</description>
        <pubDate>Wed, 27 Sep 2017 13:00:00 +0900</pubDate>
        <link>http://localhost:8080/kakao-blind-recruitment-round-1/</link>
        <guid isPermaLink="true">http://localhost:8080/kakao-blind-recruitment-round-1/</guid>
        
        <category>kakao</category>
        
        <category>recruitment</category>
        
        
      </item>
    
      <item>
        <title>kakao의 오픈소스 Ep8 - hbase-packet-inspector</title>
        <description>&lt;p&gt;&lt;a id=&quot;forkme&quot; href=&quot;https://github.com/kakao/hbase-packet-inspector&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;hbase-packet-inspector&quot;&gt;hbase-packet-inspector&lt;/h1&gt;

&lt;p&gt;이번에 카카오에서 오픈소스로 공개한 &lt;a href=&quot;https://github.com/kakao/hbase-packet-inspector&quot;&gt;hbase-packet-inspector&lt;/a&gt; (이하 HPI)
는 &lt;a href=&quot;http://hbase.apache.org/&quot;&gt;HBase&lt;/a&gt; &lt;a href=&quot;https://hbase.apache.org/book.html#regionserver.arch&quot;&gt;리젼서버&lt;/a&gt;의 네트워크 패킷을 분석해 요청과 응답 정보를
추출하는 툴입니다. 기존의 모니터링 툴을 통해서는 알 수 없었던 보다 상세한
정보들을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;먼저 왜 이런 툴이 필요했는지 이야기해봐야 할 것 같습니다.&lt;/p&gt;

&lt;h2 id=&quot;배경동기&quot;&gt;배경/동기&lt;/h2&gt;

&lt;p&gt;카카오와 다음의 많은 서비스들은 &lt;a href=&quot;http://hbase.apache.org/&quot;&gt;HBase&lt;/a&gt; 를 중요한 데이터 저장소로
사용하고 있습니다. 서비스 간의 간섭을 피하기 위해 개별 서비스는 각각 독립적인
HBase 클러스터를 사용하는 것이 원칙이며, 그러다 보니 실제 운영 중인 HBase
클러스터는 수십 개에 이릅니다. 각 클러스터의 데이터 스키마와 액세스 패턴,
워크로드는 모두 상이하지요.&lt;/p&gt;

&lt;p&gt;그리고 이 모든 클러스터를 5명의 인원이 시간을 나누어 운영하고 있습니다. 때문에
각 클러스터의 서비스적 특성을 모두 세밀하게 파악하고 있지 못한 것이
현실입니다. 물론 최초 클러스터 투입 시점에 전반적인 리뷰 프로세스를 거치지만
시간이 지나며 초기와는 다른 양상으로 흘러가기도 하니까요.&lt;/p&gt;

&lt;p&gt;이러한 상황에서 서비스 장애는 발생하고, 우리는 최대한 빨리 이에 대응해야
합니다. 긴급한 서비스 장애 상황에서 빠르게 문제 원인을 파악할 수 있는 방법들이
필요합니다.&lt;/p&gt;

&lt;h3 id=&quot;일반적인-경우&quot;&gt;일반적인 경우&lt;/h3&gt;

&lt;p&gt;많은 경우 기본적인 모니터링만으로도 문제 파악이 가능합니다. 각 서버의 시스템
리소스 사용량이나 HBase 가 제공하는 서버 별, 리젼 별 메트릭을 확인하면
대부분의 경우는 어떠한 부분이 문제가 되고 있는지 바로 알 수 있고, 그에 대한
대응 프로세스는 이미 마련되어 있죠.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/hpi-cloudera-manager.png&quot; alt=&quot;Cloudera Manager 에서 조회한 HBase 메트릭&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/hri.png&quot; alt=&quot;hbase-region-inspector 를 이용한 리젼 별 메트릭 확인&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;예외적인-경우&quot;&gt;예외적인 경우&lt;/h3&gt;

&lt;p&gt;하지만 예측 범위를 벗어난 예외적인 경우들이 문제입니다. 평상시와 다른
비정상적 클라이언트 동작, 비정상적인 액세스 패턴, 또는 비정상적 데이터로 인한
문제가 발생할 경우 서버 단위의, 혹은 리젼 단위의 coarse-grained 지표만
가지고는 빠른 문제 파악이 어렵습니다.&lt;/p&gt;

&lt;p&gt;정확히 어떤 데이터가, 어떤 클라이언트의 어떤 오퍼레이션에 의해, 어떤 빈도로
조회되고 갱신되고 있는지 정확히 진단할 수 있는 방법이 필요했습니다. &lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;구체적으로 예를 들어 어떤 로우키 (row key) &lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; 로 액세스가 집중되고 있는지
파악이 필요한 경우가 있었습니다. 특정 레코드로 쓰기가 집중될 경우 경합이
발생하게 되고 시스템 리소스에 여유가 있음에도 불구하고 애플리케이션 성능은
낮게 나타날 수 있습니다. 일반적인 모니터링 지표 (CPU 사용량, HBase 리퀘스트
처리량 등) 로는 감지하기 어려운 상황입니다. 이런 상황을 파악하고, 문제가 되는
레코드를 정확히 확인할 수 있다면 효과적인 대응이 가능하겠죠.&lt;/p&gt;

&lt;p&gt;기존의 모니터링 도구로는 대응이 불가능한 부분이었고, 담당 서비스 팀에서도
정확한 추적이 어려운 상황이었습니다. 마지막 수단으로 &lt;a href=&quot;https://github.com/jpr5/ngrep/blob/master/EXAMPLES.md&quot;&gt;ngrep&lt;/a&gt; 을 이용해
네트워크 패킷의 바이트 스트림을 눈으로 따라가 보았습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/hpi-ngrep.png&quot; alt=&quot;ngrep 으로 확인한 HBase 리젼서버 패킷 스트림&quot; /&gt;&lt;/p&gt;

&lt;p&gt;테이블명, 오퍼레이션 타입, 접근하는 로우키 정보들을 어렴풋이 확인할
수 있습니다. 여기서 많이, 자주 보이는 로우키들을 기억해서 서비스 담당팀에
전달하는 것이 당시 우리가 할 수 있는 최선이었죠. 프로세스는 비효율적이고
부정확했습니다.&lt;/p&gt;

&lt;p&gt;흔히 발생하는 상황은 아니었지만, 그 후로도 이러한 경우들이 여러 번 반복되었고,
보다 체계적으로 대응해야 할 필요성을 느끼게 됩니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;“이럴 거면 제대로 까 봅시다.”&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;HBase 프로토콜을 이해하는 패킷 분석 도구를 만들기로 했습니다. 명칭은 이미
오픈소스로 공개한 &lt;a href=&quot;http://tech.kakao.com/2016/03/11/opensource-3-hri/&quot;&gt;hbase-region-inspector&lt;/a&gt; 와 유사하게
&lt;em&gt;hbase-packet-inspector&lt;/em&gt; 로 정했습니다.&lt;/p&gt;

&lt;h2 id=&quot;hbase-rpc&quot;&gt;HBase RPC&lt;/h2&gt;

&lt;p&gt;개발을 위해선 HBase RPC 에 대한 이해가 필요합니다. 다행히 HBase 의 RPC
프로토콜은 단순한 편으로 문서화가 잘되어 있고, &lt;a href=&quot;https://developers.google.com/protocol-buffers/&quot;&gt;Protocol Buffer&lt;/a&gt;
기반이므로 관련 &lt;code class=&quot;highlighter-rouge&quot;&gt;.proto&lt;/code&gt; 파일들을 들여다보면 메시지 구조를 모두
알 수 있습니다. &lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://hbase.apache.org/book.html#hbase.rpc&quot;&gt;HBase RPC Specification&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/apache/hbase/tree/master/hbase-protocol/src/main/protobuf&quot;&gt;HBase Protocol Buffer message 정의&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;HBase 의 RPC 는 간단하게 다음 그림으로 요약할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/hpi-rpc.png&quot; alt=&quot;HBase RPC 의 기본 구조&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;리젼서버와 클라이언트가 주고받는 모든 메시지는 메시지의 길이를 나타내는
4-byte integer 로 시작합니다.&lt;/li&gt;
  &lt;li&gt;한 가지 예외는 최초 커넥션 생성 시 클라이언트가 전송하는 메시지로, 길이 정보
대신 &lt;code class=&quot;highlighter-rouge&quot;&gt;HBas&lt;/code&gt; 라는 특수 문자열을 전송합니다. 해당 메시지는 우리가 원하는 정보를
추출하는 데 있어 중요하지 않으므로 무시합니다.&lt;/li&gt;
  &lt;li&gt;요청 (request) 의 경우 길이를 나타내는 4-byte integer 뒤에
&lt;a href=&quot;https://github.com/apache/hbase/blob/rel/1.2.0/hbase-protocol/src/main/protobuf/RPC.proto#L114-L126&quot;&gt;RequestHeader&lt;/a&gt; 가 따르고, 요청의 상세 정보를 담은
파라미터가 이어집니다. 쓰기 오퍼레이션의 경우 추가적으로 데이터가 붙게
됩니다.&lt;/li&gt;
  &lt;li&gt;응답 (response) 도 유사한 형태인데 &lt;a href=&quot;https://github.com/apache/hbase/blob/rel/1.2.0/hbase-protocol/src/main/protobuf/RPC.proto#L114-L126&quot;&gt;RequestHeader&lt;/a&gt; 대신
&lt;a href=&quot;https://github.com/apache/hbase/blob/rel/1.2.0/hbase-protocol/src/main/protobuf/RPC.proto#L128-L134&quot;&gt;ResponseHeader&lt;/a&gt; 가 붙습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;RequestHeader 와 ResponseHeader 의 Protocol Buffer message 정의는 다음과
같습니다.&lt;/p&gt;

&lt;div class=&quot;language-protobuf highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RequestHeader&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;optional&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;call_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;optional&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RPCTInfo&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;trace_info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;optional&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;method_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;optional&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;request_param&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;optional&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CellBlockMeta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;cell_block_meta&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;optional&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;priority&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ResponseHeader&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;optional&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;call_id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;optional&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ExceptionResponse&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;exception&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;optional&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CellBlockMeta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;cell_block_meta&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;요청의 경우 RequestHeader 를 보면 어떤 타입의 요청인지 (&lt;code class=&quot;highlighter-rouge&quot;&gt;method_name&lt;/code&gt;), 어떤
파라미터로 요청되었는지 모두 알 수 있지만, 응답의 경우 그러한 정보가
직접적으로 주어져 있지 않아 매칭 되는 요청을 &lt;code class=&quot;highlighter-rouge&quot;&gt;call_id&lt;/code&gt; 기준으로 찾아봐야
합니다. 따라서 HPI 는 패킷 스트림을 분석하면서 &lt;code class=&quot;highlighter-rouge&quot;&gt;call_id&lt;/code&gt; 에 해당하는 원래의
요청을 내부 상태로 기억하고 관리합니다.&lt;/p&gt;

&lt;p&gt;커넥션의 단절, 또는 pcap 의 &lt;a href=&quot;https://unix.stackexchange.com/questions/144794/why-would-the-kernel-drop-packets&quot;&gt;패킷 드랍&lt;/a&gt;으로 인해, 요청에 대한 응답을 HPI
가 보지 못하는 경우들이 발생할 수 있습니다. 이러한 경우들이 장기간 누적되면
내부 상태 관리에 필요한 메모리 사이즈가 지속적으로 증가하므로 이를 시간 기준,
사용 메모리 기준으로 정리하는 로직도 구현해야 합니다.&lt;/p&gt;

&lt;p&gt;RequestHeader 의 &lt;code class=&quot;highlighter-rouge&quot;&gt;method_name&lt;/code&gt; 에 따라 해당 요청 타입에 맞는 메시지가
파라미터로 따라오게 되는데요, 간단한 예로 Get 요청의 경우 다음과 같은 메시지를
사용합니다.&lt;/p&gt;

&lt;div class=&quot;language-protobuf highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;GetRequest&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;required&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RegionSpecifier&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;region&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;required&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Get&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RegionSpecifier&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;required&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RegionSpecifierType&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;required&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bytes&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 후략
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Get&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;required&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bytes&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;row&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;repeated&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Column&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;column&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;repeated&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NameBytesPair&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;attribute&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;optional&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Filter&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;filter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;optional&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TimeRange&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;time_range&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;optional&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint32&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;max_versions&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;optional&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;cache_blocks&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 후략
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;우리가 원하는 정보 – 어떤 리젼을 향하는 요청인지, 어떤 로우키에 대한 요청인지
등 – 를 모두 추출할 수 있죠.&lt;/p&gt;

&lt;p&gt;Scan 의 경우는 조금 복잡한데요, 하나의 scan 작업은 최초의 &lt;code class=&quot;highlighter-rouge&quot;&gt;open scanner&lt;/code&gt;, 1번
이상의 &lt;code class=&quot;highlighter-rouge&quot;&gt;next rows&lt;/code&gt;, 최종 &lt;code class=&quot;highlighter-rouge&quot;&gt;close scanner&lt;/code&gt; 의 세 번 이상의 RPC 로 구성되고 &lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;,
이들은 개별적인 RPC 로서 서로 다른 &lt;code class=&quot;highlighter-rouge&quot;&gt;call_id&lt;/code&gt; 를 갖습니다. 이들을 이어주는 것은
&lt;code class=&quot;highlighter-rouge&quot;&gt;open scanner&lt;/code&gt; 응답에 포함된 &lt;code class=&quot;highlighter-rouge&quot;&gt;scanner_id&lt;/code&gt; 로 이를 내부 상태로 관리하고 연관된
RPC 를 묶어주는 작업이 필요합니다.&lt;/p&gt;

&lt;p&gt;추가적으로 패킷 분석 시 신경 써야 했던 부분들은 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;메시지 크기가 &lt;a href=&quot;https://en.wikipedia.org/wiki/Maximum_transmission_unit&quot;&gt;MTU&lt;/a&gt;
1500 바이트를 초과하는 경우 하나의 메시지가 여러 패킷에 걸쳐 전송됩니다.
이를 합쳐 원래의 온전한 메시지를 복원해야 합니다.&lt;/li&gt;
  &lt;li&gt;반대로 하나의 패킷에 여러 개의 메시지가 붙어 있는 경우도 있습니다. 이런
경우는 &lt;a href=&quot;https://github.com/OpenTSDB/asynchbase&quot;&gt;Asynchbase 클라이언트&lt;/a&gt; 사용 시 자주 관찰되는데요.
한 패킷에 포함된 여러 메시지 중 마지막 메시지의 경우 온전한 형태가 아니라
다음 패킷에 걸쳐 있을 수도 있으므로 이에 대한 처리도 해주어야 했습니다.&lt;/li&gt;
  &lt;li&gt;패킷 스트림이 stateful 하므로 병렬 처리 시에는 클라이언트의 IP 와 port
기준으로 multiplexing 해야 합니다. 현재 HPI 는 패킷을 캡처하는 thread
와 이를 HBase 요청과 응답으로 해석하는 thread, 두 개의 thread 만 사용하고
있으므로 이러한 구현은 하지 않고 있습니다. 병렬도를 늘린다면 HPI 의 처리
성능을 높여 더 정확한 통계를 얻을 수 있겠지만, 더 많은 CPU 를 사용하게
되므로 HPI 를 리젼서버 상에서 실행하는 경우에는 원하는 동작이 아닐
수 있겠지요.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;sql-기반의-분석-도구-제공&quot;&gt;SQL 기반의 분석 도구 제공&lt;/h2&gt;

&lt;p&gt;원하는 정보를 추출했다면, 이를 어떻게 보여줄 것인가의 고민이 이어집니다.
최초에는 &lt;a href=&quot;http://tech.kakao.com/2016/03/11/opensource-3-hri/&quot;&gt;hbase-region-inspector&lt;/a&gt; 와 유사하게 웹을 통한 시각화를
고려했지만, 요구 사항을 나열해보니 난감했어요.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;가장 많이 액세스가 이루어지는 로우키의 목록은?&lt;/li&gt;
  &lt;li&gt;특정 리젼에서 increment 오퍼레이션이 가장 많이 일어나는 로우키의 목록은?&lt;/li&gt;
  &lt;li&gt;20KB 이상의 check and put 요청을 보내는 클라이언트들이 접근하는 리젼 별 평균
응답 시간은?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;생각해보면 끝이 없습니다. 이토록 다양한 형태의 요구를 모두 수용할 수 있을 만큼
강력하고 유연한 사용자 인터페이스는 무엇이 있을까, 우리의 오랜 친구 &lt;a href=&quot;https://en.wikipedia.org/wiki/SQL&quot;&gt;SQL&lt;/a&gt;
이 떠올랐습니다. 위의 요구 사항은 다음과 같이 표현해볼 수 있겠네요.&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;-- 가장 많이 액세스가 이루어지는 로우키의 목록은?&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requests&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;row&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;row&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;desc&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;-- 특정 리젼에서 increment 오퍼레이션이 가장 많이 일어나는 로우키의 목록은?&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;row&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requests&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'increment'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;region&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'a073a39457e367c197fb0ae5af4d5656'&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;row&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;desc&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;-- 20KB 이상의 check and put 요청을 보내는 클라이언트들이 접근하는 리젼별 평균 응답 시간은?&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;region&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;avg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elapsed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;responses&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;client&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;distinct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;client&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;requests&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;method&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'check-and-put'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1024&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;region&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;desc&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;미려한 시각화는 없지만 유연하고 강력합니다. SQL 인터페이스를 제공하기로
결정합니다.&lt;/p&gt;

&lt;p&gt;빠르고 간단하게 실행할 수 있는 툴을 만드는 것이 목표였기 때문에 외부
데이터베이스 연동을 고려하지는 않았고 &lt;sup id=&quot;fnref:5&quot;&gt;&lt;a href=&quot;#fn:5&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;, &lt;a href=&quot;http://www.h2database.com/html/main.html&quot;&gt;H2 데이터베이스&lt;/a&gt;를 내장해
메모리 데이터베이스에 적재하기로 했습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.h2database.com/html/main.html&quot;&gt;H2&lt;/a&gt; 가 제공하는 큰 장점은 &lt;a href=&quot;http://www.h2database.com/html/features.html&quot;&gt;커맨드 라인과 웹 기반의 SQL 인터페이스를
내장&lt;/a&gt;하고 있다는 점이었는데요, 덕분에 사용자 인터페이스를 개발하는데
시간을 전혀 들이지 않고 빠른 프로토타이핑이 가능했습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/hpi-archi-h2.png&quot; alt=&quot;HPI 의 기본 동작 방식&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;실행-화면&quot;&gt;실행 화면&lt;/h2&gt;

&lt;p&gt;HPI 를 실행하면 지정한 네트워크 인터페이스에 대한 패킷 캡처를 시작합니다.
분석한 내용을 메모리 데이터베이스에 적재하므로, 마냥 계속 유지할 수는 없고
heap 영역 부족이 발생하기 전에 중단해야 합니다. 지정된 시간 동안
(&lt;code class=&quot;highlighter-rouge&quot;&gt;--duration&lt;/code&gt;) 혹은 지정된 개수의 패킷을 처리할 때까지 (&lt;code class=&quot;highlighter-rouge&quot;&gt;--count&lt;/code&gt;) 유지하도록
할 수도 있고, 사용자의 키 입력 시점까지 유지할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;아래 보시는 내용은 50만 개의 패킷을 처리한 시점에서 처리를 중단한 후, H2
가 제공하는 SQL 인터페이스로 데이터를 조회해보는 모습입니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;...
2017-09-21 16:35:04,535 INFO : Processed 480000 packets (received: 492384, dropped: 2395)
2017-09-21 16:35:05,163 INFO : Processed 490000 packets (received: 502395, dropped: 2395)
2017-09-21 16:35:05,966 INFO : Processed 500000 packets (received: 513683, dropped: 2395)

2017-09-21 16:35:06,513 INFO : Closing the handle
2017-09-21 16:35:06,514 INFO : 520487 packets received, 2395 dropped
2017-09-21 16:35:06,541 INFO : Closed.
2017-09-21 16:35:06,987 INFO : Started web server: http://10.41.200.107:44764/frame.jsp?jsessionid=4af2da9103cf1ab23aeb2a311ea8c32f

Welcome to H2 Shell 1.4.196 (2017-06-10)
Exit with Ctrl+C
Commands are case insensitive; SQL statements end with ';'
help or ?      Display this help
list           Toggle result list / stack trace mode
maxwidth       Set maximum column width (default is 100)
autocommit     Enable or disable autocommit
history        Show the last 20 statements
quit or exit   Close the connection and exit

sql&amp;gt; select region, avg(elapsed)
...&amp;gt; from responses
...&amp;gt; where client in (
...&amp;gt;   select distinct client from requests
...&amp;gt;   where method = 'check-and-put' and size &amp;gt; 2 * 1024
...&amp;gt; )
...&amp;gt; group by region
...&amp;gt; order by 2 desc limit 10;
REGION                           | AVG(ELAPSED)
560fcf63b0d5e2c0a8eeb24d059e9086 | 29
25b02705b538e0c4ef3106d65c4ff361 | 26
0f7809869670099eee30fe888d05daf9 | 18
30f4980bcb0896b6223afaf091ccd835 | 12
cc5c83f20f539a6afb128e42b8f4a484 | 10
310d99ff905ee048ad50af1f5aed6ace | 5
3b75c4e8dc9ee657e8ab760e5d3f8409 | 3
2e53b71ef48001513556a6692d8230ec | 3
af3a3c9ec5036e9f0133e7a73f54bb20 | 3
5472a30b635d789ac7d4cf482af53030 | 3
(10 rows, 245 ms)
sql&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;그리고 앞서 언급한 것처럼 웹 기반의 SQL 인터페이스가 공짜로 따라오지요.
화려하진 않지만 원하는 기능은 모두 수행할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/hpi-h2-web.png&quot; alt=&quot;H2 데이터베이스의 웹 기반 SQL 인터페이스&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;apache-kafka-연동-기능의-추가&quot;&gt;Apache Kafka 연동 기능의 추가&lt;/h2&gt;

&lt;p&gt;이 정도로도 그럭저럭 쓸만한 상태가 되었고, 한동안 잘 활용했지만 한계는
뚜렷했습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;메모리 데이터베이스이므로 수집할 수 있는 데이터의 크기가 제한적이다.
장시간에 걸친 분석이 불가능하다.&lt;/li&gt;
  &lt;li&gt;수집이 끝난 후에는 데이터베이스 내용이 더 이상 갱신되지 않으므로 워크로드의
실시간 변화를 관찰할 수 없다.&lt;/li&gt;
  &lt;li&gt;HPI 가 실행 중인 리젼서버, 혹은 애플리케이션 서버의 정보만 수집되므로
클러스터 전반의 종합적인 워크로드 파악이 불가능하다.&lt;/li&gt;
  &lt;li&gt;문제 분석의 자동화가 어렵다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;다수의 서버에서 HPI 를 중단 없이 장기간 실행하고 수집된 결과를 취합해
실시간으로 분석해보고 싶었습니다. 이에 &lt;a href=&quot;https://kafka.apache.org/&quot;&gt;Apache
Kafka&lt;/a&gt; 로의 전송 기능을 도입하게 되었습니다.&lt;/p&gt;

&lt;p&gt;Kafka 로 전송할 경우, 복수개의 consumer 를 이용해 다양한 방식으로 데이터를
가공해 유연하게 활용할 수 있다는 장점이 있습니다. 카카오에서 Kafka 가 데이터
연동 시 “사실상 표준” 도구로서 활용되고 있다는 점도 선택에 영향을 주었죠.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;java -jar hbase-packet-inspector.jar &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    --kafka &lt;span class=&quot;s2&quot;&gt;&quot;bootstrap1:9092,bootstrap2:9092//hbase-responses&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/files/hpi-archi-kafka.png&quot; alt=&quot;Kafka 전송 방식: 리젼서버에서 실행&quot; /&gt;&lt;/p&gt;

&lt;p&gt;패킷 캡처 방식은 서버의 &lt;a href=&quot;https://github.com/kakao/hbase-packet-inspector#caveats-and-known-issues&quot;&gt;최대 성능에 영향을 주는 것으로 알려져 있고&lt;/a&gt;,
HPI 도 예외는 아닙니다. 리젼서버의 부하가 높은 상황이라면 HPI 를 리젼서버가
아닌 애플리케이션 서버 쪽에서 실행하는 것이 안전하겠죠 &lt;sup id=&quot;fnref:6&quot;&gt;&lt;a href=&quot;#fn:6&quot; class=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;. HPI 는 포트
번호를 기준으로 서버 여부를 판단하므로 반드시 리젼서버 상에서 실행할 필요가
없습니다. 다음과 같은 형태가 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/hpi-archi-kafka-alt.png&quot; alt=&quot;Kafka 전송 방식: 애플리케이션 서버에서 실행&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Kafka 로 전송된 데이터는 위의 그림에 표현한 것처럼 다양한 방식으로 활용이
가능한데요, 카카오에서는 &lt;a href=&quot;https://spark.apache.org/streaming/&quot;&gt;Spark streaming&lt;/a&gt; 으로 데이터를
가공해 OLAP 엔진인 &lt;a href=&quot;http://druid.io/&quot;&gt;Druid&lt;/a&gt; 으로 실시간 전송하고
&lt;a href=&quot;https://docs.imply.io/pivot/&quot;&gt;Pivot&lt;/a&gt; 으로 시각화하여 확인하고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/files/hpi-pivot.png&quot; alt=&quot;Pivot 을 이용한 시각화. Increment 가 많이 발생하는 로우키들을 확인하고 있다.&quot; /&gt;&lt;/p&gt;

&lt;p&gt;여기서 한걸음 더 나아가 Druid API 를 이용해 주기적으로 클러스터 핫스팟 분석을
수행하고, 이에 따른 적절한 대응을 자동으로 수행하는 고도화 작업을 진행하고
있습니다.&lt;/p&gt;

&lt;h2 id=&quot;마치며&quot;&gt;마치며&lt;/h2&gt;

&lt;p&gt;아직 부족한 점들이 있지만 HPI 는 HBase 클러스터의 모니터링과 운영 프로세스를
개선하는데 적지 않은 도움을 주고 있습니다. 오픈소스 공개 이후에도 지속적으로
개선해 나갈 예정이며 비슷한 고민(과 고생)을 하신 분들께 도움이 되길 바랍니다.&lt;/p&gt;

&lt;hr /&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;원칙적으로 이러한 액세스 패턴에 대한 지표는 개별 서비스 담당팀에 의해
  추적/모니터링이 되는 것이 맞겠습니다. 하지만 여러 현실적인 이유로 그에
  대한 대비가 충분히 되지 않은 경우들이 있을 수 있고, 서비스 장애 상황에
  급하게 이에 대한 추가 개발/배포를 요구하는 것은 어렵죠.&amp;nbsp;&lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;HBase 데이터 테이블의 primary key&amp;nbsp;&lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;HPI 는 JVM 에서 동작하는 &lt;a href=&quot;https://clojure.org/&quot;&gt;Clojure&lt;/a&gt; 로 개발했으므로
  proto 파일에 대한 별도의 전처리 없이 HBase 서버와 클라이언트가 사용하는
  Java API 를 그대로 사용할 수 있습니다.&amp;nbsp;&lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot;&gt;
      &lt;p&gt;Small scan 인 경우는 예외로 한 번의 RPC 로 이루어집니다. HPI 는 small
  scan 여부를 구분합니다.&amp;nbsp;&lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:5&quot;&gt;
      &lt;p&gt;JDBC 드라이버, 유저명, 패스워드, 접속 권한, 테이블 생성 권한 …&amp;nbsp;&lt;a href=&quot;#fnref:5&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:6&quot;&gt;
      &lt;p&gt;단순히 &lt;a href=&quot;http://www.tcpdump.org/&quot;&gt;tcpdump&lt;/a&gt; 를 실행하는 것만으로도 서버의
  최대 성능이 10 ~ 15% 가량 저하되는 것을 확인할 수 있습니다 (이는 최대
  성능의 관점이며 서버의 처리량이 높지 않은 상태라면 그 정도의 차이가
  관찰되지는 않습니다). HPI 의 경우도 유사하나 HPI 는 단순한 tcpdump 보다
  더 많은 CPU 자원을 사용하므로 추가적인 주의가 필요합니다. 카카오에서는
  서비스의 안정적 운영을 위해 시스템 리소스에 어느 정도 여유가 있는
  수준으로 클러스터의 규모를 산정하기 때문에 HPI 를 추가적으로 실행하는데
  큰 무리가 없습니다.&amp;nbsp;&lt;a href=&quot;#fnref:6&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
        <pubDate>Fri, 22 Sep 2017 10:00:00 +0900</pubDate>
        <link>http://localhost:8080/opensource-8-hbase-packet-inspector/</link>
        <guid isPermaLink="true">http://localhost:8080/opensource-8-hbase-packet-inspector/</guid>
        
        <category>opensource</category>
        
        <category>hbase</category>
        
        <category>clojure</category>
        
        
      </item>
    
      <item>
        <title>카카오 코드 페스티벌 본선 이야기</title>
        <description>&lt;h2 id=&quot;드디어-본선의-막이-열렸습니다&quot;&gt;드디어 본선의 막이 열렸습니다!&lt;/h2&gt;

&lt;p&gt;지난 9월 9일 토요일, 카카오 코드 페스티벌의 오프라인 본선이 진행됐습니다. 예선에서의 엄청난 경쟁률을 뚫고 당당히 본선에 진출한 100여명의 실력자들이 함께 했는데요. 합병 후 카카오의 첫 개발자 행사인 만큼, 처음이라는 설렘을 담아 구석구석 정성스러움을 가득 담아 대회를 준비했습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.kakaocorp.co.kr/648&quot; target=&quot;_blank&quot;&gt;▶ 행사 후기가 궁금하시다면?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;코드 페스티벌의 핵심인 문제도 정말 열심히 준비했습니다! 참가자들도 “문제 모티브가 재미있어 다른 대회보다 더 즐기는 마음으로 참여할 수 있었다”는 긍정적인 피드백을 주셨는데요, (이런 피드백 무한 감사, 정말 힘이 납니다!) 본선에 출제되었던 문제에 대한 설명과 해설을 이제부터 진행하고자 합니다.&lt;/p&gt;

&lt;h2 id=&quot;문제-설명-및-풀이&quot;&gt;문제 설명 및 풀이&lt;/h2&gt;

&lt;p&gt;코드 페스티벌 본선에는 총 8문제가 출제되었습니다. 3시간이라는 짧은 시간동안 진행되었지만 참가자들의 대단한 실력을 증명하듯 모든 문제에 정답자가 있었습니다. 그럼 이제 문제를 하나하나 함께 살펴보실까요?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://t1.kakaocdn.net/codefestival/problems.pdf&quot; target=&quot;_blank&quot;&gt;문제 다운로드 (pdf, 2.2MB)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://programmers.co.kr/learn/challenges/competitions?tag=%EC%B9%B4%EC%B9%B4%EC%98%A4%EC%BD%94%EB%93%9C+%EB%B3%B8%EC%84%A0&quot; target=&quot;_blank&quot;&gt;문제 풀러 가기&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;단체사진-찍기&quot;&gt;단체사진 찍기&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;제출자 81명&lt;/li&gt;
  &lt;li&gt;정답자 78명&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;8명의 프렌즈가 나란히 서서 단체사진을 찍는데, 각자가 다른 프렌즈와 어느 정도 거리를 두고 서고 싶은지를 입력으로 받고 이 조건을 모두 만족하는 경우의 수를 구하는 문제입니다. 8명이 나란히 서는 모든 경우의 수가 &lt;code class=&quot;highlighter-rouge&quot;&gt;8! = 40,320&lt;/code&gt;으로 많지 않기 때문에, 모든 가능한 방법에 대해 조건을 모두 만족하는지를 확인하면 됩니다. C++의 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;next_permutation&lt;/code&gt; 함수를 이용하면 빠르게 코드를 작성할 수 있으며, 이를 사용하지 않고 직접 가능한 경우의 수를 모두 생성하거나 8중 반복문으로 조건을 확인해도 개수가 많지 않아 제한 시간 안에 답을 구할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;gps&quot;&gt;GPS&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;제출자 65명&lt;/li&gt;
  &lt;li&gt;정답자 50명&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;택시가 다니는 거점과 도로의 정보, 그리고 택시가 시간대 별로 보낸 현재 위치가 입력으로 주어집니다. 단 현재 위치와 다음 위치를 연결하는 도로가 없을 경우 이동이 불가능하며, 이와 같은 오류를 최소한으로 수정하여 이동 가능한 경로로 만드는 것이 목표인 문제입니다.&lt;/p&gt;

&lt;p&gt;동적 계획법(Dynamic Programming)으로 풀 수 있습니다. 다음과 같은 2차원 배열을 정의하고 순서대로 값을 채워나가면 됩니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;S[i][j]: 경로의 i번째 값이 j가 되는 경우, i번째까지의 경로가 valid하도록 고쳐야 하는 최소 횟수,
         그러한 수정이 불가능하다면 INF
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;승차 위치는 오류가 없기 때문에 &lt;code class=&quot;highlighter-rouge&quot;&gt;S[0][j]&lt;/code&gt;의 값은 &lt;code class=&quot;highlighter-rouge&quot;&gt;j&lt;/code&gt;가 입력된 승차 위치인 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;, 그렇지 않은 경우 &lt;code class=&quot;highlighter-rouge&quot;&gt;INF&lt;/code&gt;입니다. 그리고 &lt;code class=&quot;highlighter-rouge&quot;&gt;i&amp;gt;0&lt;/code&gt;인 경우의 값은 &lt;code class=&quot;highlighter-rouge&quot;&gt;i-1&lt;/code&gt;번째의 값을 참조하여 계산할 수 있습니다. 이때 택시가 특정 위치에 계속 머무르는 것이 가능하기 때문에 계산할 때 이를 고려해야 합니다. 모든 값을 구한 뒤 입력된 하차 위치 &lt;code class=&quot;highlighter-rouge&quot;&gt;j&lt;/code&gt;에 대해 &lt;code class=&quot;highlighter-rouge&quot;&gt;S[k-1][j]&lt;/code&gt;를 구하면 됩니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;O(k(n+m))&lt;/code&gt;의 시간복잡도로 답을 구할 수 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;리틀-프렌즈-사천성&quot;&gt;리틀 프렌즈 사천성&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;제출자 62명&lt;/li&gt;
  &lt;li&gt;정답자 49명&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2차원 배열이 주어지고, 사천성 게임의 규칙에 따라 블록을 제거하는 방법을 구하는 문제입니다. 단 원래의 사천성 규칙에 비해 경로의 꺾는 횟수가 한 번으로 줄어들었고 모든 블록이 항상 두 개씩만 존재한다는 조건이 추가되었습니다. 그리고 블록은 알파벳 대문자로 표시되기 때문에 최대 26개만 존재할 수 있습니다. 가능한 방법이 여러 가지인 경우 알파벳 순으로 가장 먼저인 문자열을 리턴하는 조건이 있기 때문에, 입력된 초기 상태부터 &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;부터 &lt;code class=&quot;highlighter-rouge&quot;&gt;Z&lt;/code&gt;까지 확인하며 같은 글자의 두 블록이 제거 가능한지 확인하는 과정을 반복하면 됩니다. 게임판의 크기가 크지 않기 때문에 단순한 방법으로도 경로 확인이 가능한데, 그중 한 가지는 각 블록에서 상/하/좌/우로 다른 블록이나 장애물에 막히지 않고 갈 수 있는 위치의 집합을 구한 뒤 두 집합의 공통 원소가 있는지를 확인하는 방법이 있습니다.&lt;/p&gt;

&lt;h3 id=&quot;튜브의-소개팅&quot;&gt;튜브의 소개팅&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;제출자 70명&lt;/li&gt;
  &lt;li&gt;정답자 47명&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2차원 배열이 입력으로 주어질 때, 왼쪽 위에서 오른쪽 아래로 이동하면서 길이가 최소인 경로, 길이가 같다면 대화 시간의 합이 가장 작은 경로를 구하는 문제입니다. 단 총 대화 시간의 합은 입력된 &lt;code class=&quot;highlighter-rouge&quot;&gt;s&lt;/code&gt;를 넘지 않아야 합니다. 먼저 다음과 같은 3차원 배열을 정의합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;S[i][j][k]: 왼쪽 위에서 (i, j)까지 k의 길이로 이동할 때 대화 시간의 최솟값
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;이를 채우는 방법은 Dijkstra 알고리즘 등을 이용하면 됩니다. 모든 값을 계산한 뒤 &lt;code class=&quot;highlighter-rouge&quot;&gt;S[m-1][n-1][k] &amp;lt;= s&lt;/code&gt;인 최소의 &lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt;가 최소 경로의 길이, 배열에 저장된 값이 대화 시간의 합이 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;몸짱-트레이너-라이언의-고민&quot;&gt;몸짱 트레이너 라이언의 고민&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;제출자 30명&lt;/li&gt;
  &lt;li&gt;정답자 12명&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;헬스장의 예약 내역이 입력으로 주어질 때, 예약한 회원들 간의 락커의 거리를 최대로 하는 배치를 구하는 문제입니다. 단 영업시간을 통틀어 할당된 락커 간 최소거리를 최대화하는 것이 목적이기 때문에 손님이 입장한 순간 거리를 최대로 하는 위치에 배정해주는 것보다 앞으로 입장할 손님을 고려하여 배치하는 것이 최적입니다. 결국 회원의 수가 최대인 시간대의 최적 배치를 구하면 기타 시간대에는 그 배치의 부분집합을 사용하면 되므로, 락커의 크기와 락커를 사용하는 최대 인원에 의해 답이 결정됩니다.&lt;/p&gt;

&lt;p&gt;문제를 살짝 바꾸어, 락커의 크기와 최소 거리가 입력으로 주어졌을 때 최대 락커의 수를 구하는 문제를 생각해봅시다. 이 문제를 풀 수 있으면 원래의 문제인 락커를 사용하는 최대 인원에 대해 최소 거리를 구하는 문제도 풀 수 있습니다. 선택된 모든 락커의 거리가 &lt;code class=&quot;highlighter-rouge&quot;&gt;d&lt;/code&gt; 이상이 되도록 최대의 개수로 락커를 선택하기 위해, 각각의 락커를 그래프의 정점으로 두고, 거리가 &lt;code class=&quot;highlighter-rouge&quot;&gt;d&lt;/code&gt; 이상인 락커를 간선으로 잇는 그래프를 만듭니다. 이렇게 만들어진 그래프에서 최대 완전 부분 그래프를 구하면 그 크기가 답이 됩니다. 최대 완전 부분 그래프를 구하는 효율적인 방법은 알려져 있지 않지만, 이 문제의 경우 그래프의 크기가 크지 않고, 자명한 경우에 대해서는 그래프를 찾지 않고도 답을 구할 수 있기 때문에 문제의 크기를 더 줄일 수 있습니다. 가령 거리가 1인 경우는 모든 락커를 사용하는 경우이고, 거리가 2인 경우는 락커를 한 칸씩 건너 사용하는 경우(체크무늬 형태)입니다. 이와 같이 오래 걸리는 경우를 제외하고, 탐색 과정에서 적절한 가지치기(pruning)를 하면 됩니다. 단 이 경우에도 제한 시간 안에 모든 경우에 대한 답을 구하기 힘들 수 있는데, 답을 구해야 하는 경우의 수가 많지 않기 때문에 (락커의 크기가 최대 10이고 락커를 사용하는 최대 인원은 100명으로, 가능한 모든 조합에 대해 답을 구한다고 해도 그 수가 많지 않습니다.) 모든 가능한 경우에 대해 답을 구해놓고 이를 리턴하는 식으로 코드를 작성하는 것도 가능합니다.&lt;/p&gt;

&lt;h3 id=&quot;네오의-귀걸이&quot;&gt;네오의 귀걸이&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;제출자 8명&lt;/li&gt;
  &lt;li&gt;정답자 5명&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;주어진 점에 대해, 서로 꼭짓점이 연결되는 직사각형의 형태로 구성된 ‘기하학적으로 아름다운 귀걸이’를 만들 수 있는 경우의 수를, 점이 추가 혹은 삭제되는 각각의 경우에 대해 계산하는 문제입니다. 점의 개수 및 점을 추가하거나 삭제하는 변화의 수가 최대 100,000이기 때문에 &lt;code class=&quot;highlighter-rouge&quot;&gt;O(n log n)&lt;/code&gt;의 시간복잡도로 해결해야 합니다.&lt;/p&gt;

&lt;p&gt;각각의 점 &lt;code class=&quot;highlighter-rouge&quot;&gt;(x_i, y_i)&lt;/code&gt;에 대해 &lt;code class=&quot;highlighter-rouge&quot;&gt;z_i = y_i - x_i&lt;/code&gt;를 정의합니다. 즉, &lt;code class=&quot;highlighter-rouge&quot;&gt;z_i&lt;/code&gt;는 &lt;code class=&quot;highlighter-rouge&quot;&gt;(x_i, y_i)&lt;/code&gt;를 지나는 기울기가 1인 직선의 &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;절편이 됩니다. 이를 기준으로 내림차순 정렬을 한 뒤 다음과 같은 배열을 정의하여 채웁니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Dp_1[i][j]: z를 내림차순 정렬했을 때, i번째 값을 절편으로 가지고 기울기가 1인 직선 위에 존재하는 점 중,
            x좌표로 내림차순 정렬했을 때 j번째에 위치한 점이 직사각형의 오른쪽 아래 점일 때의
            가능한 귀걸이의 경우의 수
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;이 배열의 값은 왼쪽 위에서 오른쪽 아래의 순서대로 계산하고, 값을 계산할 때에 해당 위치의 점이 가지는 특성값 &lt;code class=&quot;highlighter-rouge&quot;&gt;k&lt;/code&gt;를 &lt;code class=&quot;highlighter-rouge&quot;&gt;z&lt;/code&gt;에 더하여 참조해야 할 절편의 값을 알 수 있으며, 해당 직선 내에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;좌표가 &lt;code class=&quot;highlighter-rouge&quot;&gt;[x-k, x]&lt;/code&gt;인 구간을 참조하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;Dp_1&lt;/code&gt;값을 모두 더하면 됩니다. 즉, 다음과 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;Dp_1&lt;/code&gt;의 누적합 배열을 만들면 이분탐색을 통해 &lt;code class=&quot;highlighter-rouge&quot;&gt;Dp_1[i][j]&lt;/code&gt;를 &lt;code class=&quot;highlighter-rouge&quot;&gt;O(log n)&lt;/code&gt;에 계산할 수 있습니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Dp_1sum[i][j] = Dp_1sum[i][j-1] + Dp_1[i][j] (sum of Dp_1[i][k] for k = [0, j])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;위와 비슷하게 오른쪽 아래에서부터 올라오는 경우에 대해서도 배열을 정의합니다.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Dp_2[i][j]: z를 내림차순 정렬했을 때, i번째 값을 절편으로 가지고 기울기가 1인 직선 위에 존재하는 점 중,
            x좌표로 내림차순 정렬했을 때 j번째에 위치한 점이 직사각형의 왼쪽 위 점일 때의
            가능한 귀걸이의 경우의 수
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;이 배열의 값은 오른쪽 아래에서 왼쪽 위의 순서대로 계산합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;Dp_1&lt;/code&gt;을 계산할 때와 다르게 해당 점과 직사각형으로 연결될 오른쪽 아래 꼭짓점의 특성값이 여러 가지가 될 수 있음을 주의해야 합니다. 특정한 점에 대해 값을 계산하면서 뒤에 계산할 점에 대한 전처리를 진행하는 방식으로 계산을 진행하면 됩니다. 해당 점을 오른쪽 아래 점으로 두면서 직사각형으로 연결될 수 있는 점은 특성값의 성질에 의해 &lt;code class=&quot;highlighter-rouge&quot;&gt;z&lt;/code&gt;값이 같은 직선 상의 연속된 점이므로, 세그먼트 트리 등을 이용하여 각각의 점을 왼쪽 위 점으로 하는 경우의 수를 차례로 더해가면 됩니다. 그래서 이 배열을 계산하는 과정도 마찬가지로 &lt;code class=&quot;highlighter-rouge&quot;&gt;O(n log n)&lt;/code&gt;에 완료될 수 있으며, 이후의 연산을 위해 위의 경우와 같이 &lt;code class=&quot;highlighter-rouge&quot;&gt;Dp_2sum&lt;/code&gt; 배열을 계산합니다.&lt;/p&gt;

&lt;p&gt;그러면 초기 상태에 대해 가능한 귀걸이의 경우의 수는 점 &lt;code class=&quot;highlighter-rouge&quot;&gt;E&lt;/code&gt;에 대해 &lt;code class=&quot;highlighter-rouge&quot;&gt;Dp_1&lt;/code&gt;의 값을 계산하면 됩니다. 점이 추가되는 경우에는 추가되는 점에 대해 유효한 &lt;code class=&quot;highlighter-rouge&quot;&gt;Dp_1&lt;/code&gt;의 값과 &lt;code class=&quot;highlighter-rouge&quot;&gt;Dp_2&lt;/code&gt;의 값을 이분탐색으로 찾은 뒤, 필요한 값을 곱하여 계산할 수 있고, 점이 삭제되는 경우에는 삭제되는 점에 대한 &lt;code class=&quot;highlighter-rouge&quot;&gt;Dp_1&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;Dp_2&lt;/code&gt; 값을 가져와 그 점을 지나는 경우의 수를 구하고, 전체 경우의 수에서 이 값을 빼면 됩니다.&lt;/p&gt;

&lt;h3 id=&quot;스마트한-프로도&quot;&gt;스마트한 프로도&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;제출자 10명&lt;/li&gt;
  &lt;li&gt;정답자 3명&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그래프에서 연결하는 정점이 같은 두 간선을 인접한 간선으로 부르고, 서로 인접한 간선이 없는 간선의 집합을 매칭이라고 부릅니다. 주어진 그래프에 대해 초기 매칭과 최종 매칭이 입력으로 주어지고, 이를 매칭의 조건을 항상 만족하면서 간선을 추가하거나 삭제하여 변환하는 방법을 구하는 문제입니다. 초기 매칭 &lt;code class=&quot;highlighter-rouge&quot;&gt;M_0&lt;/code&gt;와 최종 매칭 &lt;code class=&quot;highlighter-rouge&quot;&gt;M_t&lt;/code&gt;에 대해, 다음과 같이 집합 &lt;code class=&quot;highlighter-rouge&quot;&gt;H&lt;/code&gt;를 정의합니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;H = (M_0 - M_t) U (M_t - M_0)&lt;/code&gt; 즉, 두 매칭에 공통으로 속한 간선을 제외한 간선의 집합이 됩니다. 이 집합에 속한 간선을 인접한 간선끼리 부분집합으로 묶으면 모두 다음의 경우 중 하나에 속하게 되며, 이는 &lt;code class=&quot;highlighter-rouge&quot;&gt;M_0&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;M_t&lt;/code&gt;가 모두 매칭의 조건을 만족한다는 점을 이용하여 보일 수 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;M_0 - M_t&lt;/code&gt;에 속하는 단일 간선&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;M_t - M_0&lt;/code&gt;에 속하는 단일 간선&lt;/li&gt;
  &lt;li&gt;사이클을 이루는 간선의 집합, 여기에 속한 간선은 &lt;code class=&quot;highlighter-rouge&quot;&gt;M_0 - M_t&lt;/code&gt;에 속한 간선과 &lt;code class=&quot;highlighter-rouge&quot;&gt;M_t - M_0&lt;/code&gt;에 속한 간선이 번갈아가며 이어진다.&lt;/li&gt;
  &lt;li&gt;일직선으로 이어지는 간선의 집합이면서 두 끝이 모두 &lt;code class=&quot;highlighter-rouge&quot;&gt;M_0 - M_t&lt;/code&gt;에 속하는 경우, 여기에 속한 간선은 &lt;code class=&quot;highlighter-rouge&quot;&gt;M_0 - M_t&lt;/code&gt;에 속한 간선과 &lt;code class=&quot;highlighter-rouge&quot;&gt;M_t - M_0&lt;/code&gt;에 속한 간선이 번갈아가며 이어진다.&lt;/li&gt;
  &lt;li&gt;일직선으로 이어지는 간선의 집합이면서 두 끝 중 하나 이상이 &lt;code class=&quot;highlighter-rouge&quot;&gt;M_t - M_0&lt;/code&gt;에 속하는 경우, 여기에 속한 간선은 &lt;code class=&quot;highlighter-rouge&quot;&gt;M_0 - M_t&lt;/code&gt;에 속한 간선과 &lt;code class=&quot;highlighter-rouge&quot;&gt;M_t - M_0&lt;/code&gt;에 속한 간선이 번갈아가며 이어진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;첫 번째와 두 번째에 속하는 경우는 단순히 간선을 삭제하거나 추가하면 됩니다. 세 번째의 경우는 &lt;code class=&quot;highlighter-rouge&quot;&gt;M_0 - M_t&lt;/code&gt;에 속한 간선을 삭제하면 다섯 번째 경우가 되며, 네 번째의 경우는 한쪽 끝을 삭제하면 다섯 번째 경우가 됩니다. 다섯 번째 경우에 해당하는 간선에 대해서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;M_t - M_0&lt;/code&gt;에 속하는 끝 간선을 추가한 뒤, 번갈아가며 삭제 또는 추가 연산을 적용합니다. 이상의 과정에서 간선의 수는 &lt;code class=&quot;highlighter-rouge&quot;&gt;k-2&lt;/code&gt; 이하로 내려가지 않아야 한다는 조건이 있는데, 각 부분집합에 대해 적용되는 연산은 독립적으로 적용이 가능하므로 부분집합에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;|M_t - M_0| - |M_0 - M_t|&lt;/code&gt;가 큰 순서대로 연산을 적용함으로써 간선의 수를 항상 &lt;code class=&quot;highlighter-rouge&quot;&gt;k-2&lt;/code&gt; 이상으로 유지하는 것이 가능합니다.&lt;/p&gt;

&lt;h3 id=&quot;iu와-콘의-보드게임&quot;&gt;IU와 콘의 보드게임&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;제출자 5명&lt;/li&gt;
  &lt;li&gt;정답자 1명&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/files/code-festival-round-2-con.png&quot; class=&quot;hcenter&quot; /&gt;&lt;/p&gt;

&lt;p&gt;삼각형의 세 변을 이루는 고무줄을 규칙에 따라 움직여 만들 수 있는 새로운 모양의 수를 구하는 문제입니다. 고무줄의 모양은 오목해야 한다는 조건이 있는데, 이 조건을 만족하도록 &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;를 잇는 고무줄을 이동시켜 위 그림과 같은 모양을 만든 상황을 생각해봅시다. &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;를 잇는 고무줄이 거치는 점을 순서대로 &lt;code class=&quot;highlighter-rouge&quot;&gt;P_1&lt;/code&gt;, …, &lt;code class=&quot;highlighter-rouge&quot;&gt;P_k&lt;/code&gt;라고 할 때, &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;P_1&lt;/code&gt;로 그은 연장선과 &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;P_k&lt;/code&gt;로 그은 연장선, 그리고 선분 &lt;code class=&quot;highlighter-rouge&quot;&gt;BC&lt;/code&gt;로 만들어지는 삼각형이 있을 때, &lt;code class=&quot;highlighter-rouge&quot;&gt;P_2&lt;/code&gt;, …, &lt;code class=&quot;highlighter-rouge&quot;&gt;P_k-1&lt;/code&gt;은 모두 삼각형 안에 들어가게 되며, 삼각형 영역 중 고무줄 위쪽에 속하는 부분에는 점이 없어야 합니다. 그리고 모든 고무줄은 오목한 모양으로만 이동이 가능하므로 &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;를 잇는 고무줄, 혹은 &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;를 잇는 고무줄은 삼각형 내부의 점을 지날 수 없습니다. 삼각형 안에 있는 점을 지날 수 있는 고무줄은 &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;를 잇는 고무줄이 유일하고 이들 점이 오목한 형태로 이어져야 하므로, &lt;code class=&quot;highlighter-rouge&quot;&gt;P_1&lt;/code&gt;과 &lt;code class=&quot;highlighter-rouge&quot;&gt;P_k&lt;/code&gt;가 정해지면 &lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;C&lt;/code&gt;를 잇는 고무줄의 모양은 유일하게 정해지게 됩니다. 즉, 각 고무줄에 대해 양 끝 점을 정한 뒤 만들어지는 모양이 규칙을 만족하는지 보면 됩니다. 단 이 경우 살펴봐야 하는 모양의 수가 &lt;code class=&quot;highlighter-rouge&quot;&gt;O(n^6)&lt;/code&gt;이 되어 제한시간 안에 모두 살펴볼 수 없습니다.&lt;/p&gt;

&lt;p&gt;더 생각을 발전시켜 보면, 각 고무줄의 왼쪽 끝점만 정해지면 그에 따라 오른쪽 끝점이 유일하게 결정됨을 알 수 있습니다. 그렇게 각 고무줄에 대응되는 왼쪽 끝점을 정하고, 만들어지는 모양이 문제에서 제시된 조건을 만족하는지를 보면 됩니다. 삼각형의 꼭짓점에서 각 고무줄의 왼쪽 끝점을 지나는 연장선을 그었을 때 만들어지는 삼각형의 내부에 점이 없으면 조건이 성립하는 경우임을 알 수 있습니다. 그래서 총 &lt;code class=&quot;highlighter-rouge&quot;&gt;O(n^3)&lt;/code&gt;의 경우의 수를 살펴보면 됩니다.&lt;/p&gt;

&lt;h2 id=&quot;결과-발표&quot;&gt;결과 발표&lt;/h2&gt;

&lt;p&gt;그럼 이제, 코드 페스티벌 본선의 결과를 공개합니다! 예선과 같은 방식으로 채점이 진행되었으며, 1등은 출제된 8문제 중 6문제를 풀어주셨습니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://t1.kakaocdn.net/codefestival/round-2-scoreboard/index.html&quot; target=&quot;_blank&quot;&gt;▶ 순위표 보러 가기&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;사전에 공지된 대로 우수한 성적을 거둔 상위 21명의 참가자에게 상장 및 상금이 수여되었습니다. 아쉽게 수상권에 들지 못한 분들을 위해 다양한 특별상도 준비했는데요, 수상하신 모든 분들 모두 축하드립니다!&lt;/p&gt;

&lt;p&gt;카카오의 첫 개발자 행사를 즐겨주신 분들께 감사드리며, 앞으로 있을 개발자 행사에도 많은 관심 부탁드립니다 :)&lt;/p&gt;
</description>
        <pubDate>Thu, 14 Sep 2017 08:00:00 +0900</pubDate>
        <link>http://localhost:8080/code-festival-round-2/</link>
        <guid isPermaLink="true">http://localhost:8080/code-festival-round-2/</guid>
        
        <category>code-festival</category>
        
        <category>programming-contest</category>
        
        
      </item>
    
  </channel>
</rss>
